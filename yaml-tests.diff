diff --git a/README.md b/README.md
index bb9f195..d66cd1b 100644
--- a/README.md
+++ b/README.md
@@ -558,6 +558,279 @@ To run the tests for a specific package, use the `--filter` flag:
 pnpm --filter @agenteract/react test
 ```
 
+### **YAML Test Runner**
+
+Agenteract includes a declarative YAML test runner for end-to-end testing. Tests execute server-side within the Agenteract dev server (see [`packages/server/src/test-runner.ts`](packages/server/src/test-runner.ts)), eliminating round-trips and making tests fast and reliable.
+
+#### Quick Start
+
+Create a test file (`tests/login-flow.yaml`):
+
+```yaml
+project: expo-app
+timeout: 10000  # default timeout for waitFor steps
+
+steps:
+  - phase: "Setup"
+  - waitFor: login-button
+    timeout: 5000  # wait up to 5s for element
+
+  - phase: "Authentication"
+  - input: username-field
+    value: testuser@example.com
+  - input: password-field
+    value: testpass123
+  - tap: login-button
+
+  - phase: "Verification"
+  - waitFor: home-screen
+    timeout: 5000
+  - assert:
+      exists: welcome-message
+  - assert:
+      logContains: "Login successful"
+```
+
+Run the test:
+
+```bash
+npx @agenteract/agents test tests/login-flow.yaml
+```
+
+#### Test Step Reference
+
+**Basic Interactions:**
+- `tap: element-testID` - Simulate tap/click on element
+- `input: field-testID` + `value: "text"` - Enter text into input field
+- `longPress: element-testID` - Long press/hold gesture
+
+**Gestures:**
+- `scroll: scroll-view-testID` + `direction: down` + `amount: 200` - Scroll element
+- `swipe: card-testID` + `direction: left` + `velocity: fast` - Swipe gesture
+
+**Waiting & Timing:**
+- `waitFor: element-testID` + `timeout: 5000` - Wait for element to appear
+- `waitFor: ""` + `logContains: "message"` + `timeout: 3000` - Wait for console log
+- `sleep: 1000` - Pause execution (use sparingly - prefer `waitFor` with timeouts)
+
+**Assertions:**
+```yaml
+# Element exists
+- assert:
+    exists: element-testID
+
+# Element doesn't exist  
+- assert:
+    notExists: element-testID
+
+# Text content checks
+- assert:
+    text:
+      testID: label-testID
+      contains: "Expected"  # or use 'equals' for exact match
+
+# Console log verification
+- assert:
+    logContains: "Success message"
+```
+
+**Platform-Specific:**
+- `agentLink: agenteract://reset_state` - Send agentLink to app via WebSocket
+- `pair: simulator/emulator/physical` + `platform: ios/android` - Test deep link pairing
+
+**Pairing (`pair` step):**
+
+Tests deep link pairing by sending configuration deep links to simulators/emulators. This verifies that apps can receive and process pairing deep links correctly.
+
+```yaml
+# Pair with iOS simulator
+- pair: simulator
+  platform: ios
+  timeout: 5000
+
+# Pair with Android emulator
+- pair: emulator
+  platform: android
+  timeout: 5000
+
+# Physical device (requires manual QR scan via 'pnpm agenteract connect')
+- pair: physical
+  platform: ios  # or android
+  timeout: 10000
+```
+
+**Parameters:**
+- `pair`: Device type - `simulator`, `emulator`, or `physical`
+- `platform`: Target platform - `ios` or `android` (optional for `physical`)
+- `timeout`: Wait time after sending deep link (default: 5000ms)
+
+**How it works:**
+1. Generates a pairing deep link using the project's configured scheme
+2. For simulators/emulators: Automatically sends deep link via `xcrun simctl` or `adb`
+3. For physical devices: Logs the URL (user must scan QR code via `pnpm agenteract connect`)
+4. Waits for the app to process the deep link and establish connection
+
+**Use cases:**
+- Testing that deep link pairing works correctly in CI/CD
+- Verifying app handles configuration parameters
+- Automating simulator/emulator pairing in test flows
+- E2E tests that require fresh app pairing
+
+**Organization:**
+- `phase: "Phase Name"` - Label sections for better test output
+- `log: "Message"` - Log informational messages
+
+#### Best Practices
+
+**✅ DO:** Use `waitFor` with reasonable timeouts
+```yaml
+# Good - wait up to 5s for element
+- waitFor: login-button
+  timeout: 5000
+- tap: login-button
+
+# Good - wait up to 3s for console log
+- tap: submit-button
+- waitFor: ""
+  logContains: "Login successful"
+  timeout: 3000
+```
+
+**❌ DON'T:** Use arbitrary `sleep` delays
+```yaml
+# Bad - arbitrary wait, test runs slow even when element appears quickly
+- tap: login-button
+- sleep: 3000  # How long is enough? Too short = flaky, too long = slow
+- waitFor: home-screen
+```
+
+**Timeout Guidelines:**
+- Set timeouts long enough to be achievable under normal conditions
+- Not so long that test failures take forever to report
+- Typical range: 3-10 seconds for most UI transitions
+- Longer (20-30s) for network operations or complex rendering
+
+#### Example Tests
+
+**Gesture Test:**
+```yaml
+project: expo-app
+
+steps:
+  - phase: "Scroll Test"
+  - waitFor: scroll-view
+    timeout: 5000
+  - scroll: scroll-view
+    direction: down
+    amount: 300
+  - assert:
+      exists: bottom-element
+
+  - phase: "Swipe Test"  
+  - waitFor: swipeable-card
+    timeout: 3000
+  - swipe: swipeable-card
+    direction: left
+    velocity: fast
+  - assert:
+      notExists: swipeable-card
+```
+
+**Deep Link Test:**
+```yaml
+project: expo-app
+
+steps:
+  - phase: "Setup State"
+  - tap: increment-button
+  - tap: increment-button
+  - input: text-field
+    value: "Some text"
+
+  - phase: "Reset via AgentLink"
+  - agentLink: agenteract://reset_state
+  
+  - phase: "Verify Reset"
+  - waitFor: counter-value
+    timeout: 3000
+  - assert:
+      text:
+        testID: counter-value
+        equals: "0"
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+```
+
+**Pairing Test:**
+```yaml
+project: expo-app
+
+steps:
+  - phase: "Test Deep Link Pairing"
+  # Pair with iOS simulator
+  - pair: simulator
+    platform: ios
+    timeout: 5000
+  
+  - phase: "Wait for Connection"
+  - waitFor: login-button
+    timeout: 10000
+  
+  - phase: "Verify App Connected"
+  - assert:
+      exists: login-button
+```
+
+#### CI/CD Integration
+
+**GitHub Actions:**
+```yaml
+name: E2E Tests
+on: [push, pull_request]
+
+jobs:
+  test:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-node@v3
+        with:
+          node-version: 18
+
+      - name: Install dependencies
+        run: npm install
+
+      - name: Start Agenteract
+        run: npx @agenteract/cli dev &
+
+      - name: Run tests
+        run: |
+          npx @agenteract/agents test tests/login.yaml
+          npx @agenteract/agents test tests/navigation.yaml
+```
+
+#### Test Results
+
+Tests return JSON results for CI/CD parsing:
+
+```json
+{
+  "status": "passed",
+  "duration": 12345,
+  "steps": [
+    {
+      "step": 1,
+      "action": "waitFor",
+      "target": "login-btn",
+      "status": "passed",
+      "duration": 234
+    }
+  ],
+  "failedAt": null
+}
+```
+
 ### **Continuous Integration**
 
 Tests are run automatically on every push and pull request to the `main` branch using GitHub Actions.
diff --git a/docs/AGENTS.md b/docs/AGENTS.md
index eb421d5..c28a535 100644
--- a/docs/AGENTS.md
+++ b/docs/AGENTS.md
@@ -792,3 +792,454 @@ import { createAgentBinding } from '@agenteract/react';
 ```
 
 You can see how this is handled by agent-server requests in `https://raw.githubusercontent.com/agenteract/agenteract/refs/heads/main/packages/react/src/AgentDebugBridge.tsx`.
+
+## Tool: YAML Test Runner
+
+The YAML test runner allows you to define declarative, repeatable test flows that execute server-side. This is ideal for end-to-end testing, CI/CD pipelines, and automated verification.
+
+### Basic YAML Test Structure
+
+Create a `.yaml` file with your test steps:
+
+```yaml
+# my-test.yaml
+project: expo-app
+timeout: 10000  # default timeout for all steps
+
+steps:
+  # Wait for element to appear
+  - waitFor: login-button
+    timeout: 5000
+
+  # Tap a button
+  - tap: login-button
+
+  # Input text
+  - input: username-field
+    value: testuser
+
+  # Assert conditions
+  - assert:
+      exists: home-screen
+
+  - assert:
+      text:
+        testID: welcome-message
+        contains: Welcome
+
+  - assert:
+      logContains: "Login successful"
+
+  # Other gestures
+  - scroll: scroll-view
+    direction: down
+    amount: 200
+
+  - swipe: card-item
+    direction: left
+    velocity: fast
+
+  - longPress: menu-item
+
+  # Platform-specific operations
+  - agentLink: agenteract://reset_state
+
+  # Utility steps
+  - sleep: 1000
+  - log: "Phase 1 complete"
+  - phase: "User Login Test"  # Label for grouping
+```
+
+### Running YAML Tests
+
+**Command:**
+```bash
+pnpm agenteract-agents test <test-file.yaml>
+```
+
+**Options:**
+- `--project <name>`: Override project specified in YAML file
+- `--device <id>`: Target specific device (optional)
+- `--verbose`: Show detailed step output
+- `--bail`: Stop on first failure
+
+**Example:**
+```bash
+# Run a test file
+pnpm agenteract-agents test tests/login-flow.yaml
+
+# Override project
+pnpm agenteract-agents test tests/login-flow.yaml --project my-app
+
+# Verbose output for debugging
+pnpm agenteract-agents test tests/login-flow.yaml --verbose
+```
+
+### YAML Test Step Reference
+
+#### `waitFor`
+Waits for an element to appear in the view hierarchy or for a console log message.
+
+```yaml
+# Wait for element to exist
+- waitFor: element-testID
+  timeout: 5000  # optional, defaults to test-level timeout
+
+# Wait for element with specific text
+- waitFor: element-testID
+  timeout: 5000
+  text: Welcome
+
+# Wait for console log to appear
+- waitFor: ""
+  logContains: "Login successful"
+  timeout: 3000
+```
+
+#### `tap`
+Simulates tapping an element.
+
+```yaml
+- tap: button-testID
+  wait: 500  # optional: milliseconds to wait after tap
+```
+
+#### `input`
+Simulates text input.
+
+```yaml
+- input: text-field-testID
+  value: "text to input"
+```
+
+#### `scroll`
+Scrolls a scrollable element.
+
+```yaml
+- scroll: scroll-view-testID
+  direction: down  # up, down, left, right
+  amount: 200  # pixels, optional (default: 100)
+```
+
+#### `swipe`
+Simulates a swipe gesture.
+
+```yaml
+- swipe: swipeable-card-testID
+  direction: left  # up, down, left, right
+  velocity: fast  # slow, medium, fast (optional, default: medium)
+```
+
+#### `longPress`
+Simulates a long press.
+
+```yaml
+- longPress: menu-item-testID
+```
+
+#### `agentLink`
+
+Sends an agentLink to the app via the AgentDebugBridge WebSocket connection. AgentLinks use simple hostname-based routing with the `agenteract://` scheme.
+
+```yaml
+# Reset app state
+- agentLink: agenteract://reset_state
+
+# Navigate to a screen
+- agentLink: agenteract://navigate?screen=settings
+
+# Trigger any custom action
+- agentLink: agenteract://reload
+```
+
+**How it works:**
+- The URL is sent directly to the connected app via WebSocket
+- Your app's `onAgentLink` handler receives the URL
+- Parse the hostname (e.g., `reset_state`) to determine the action
+- Query parameters are available for additional data
+
+**Example handler (React/Expo):**
+```tsx
+<AgentDebugBridge 
+  projectName="expo-app" 
+  onAgentLink={async (url: string) => {
+    const { hostname, queryParams } = parseURL(url);
+    switch (hostname) {
+      case 'reset_state':
+        resetAppState();
+        return true;
+      case 'navigate':
+        navigate(queryParams.screen);
+        return true;
+      default:
+        return false;
+    }
+  }} 
+/>
+```
+
+**URL Format:**
+- Use the standard `agenteract://` scheme across all platforms
+- The hostname identifies the action: `agenteract://reset_state`
+- Add query params for data: `agenteract://navigate?screen=settings&tab=profile`
+
+**Note:** Unlike deep linking for pairing, agentLink works via the existing WebSocket connection, so no platform-specific URL scheme configuration is needed.
+
+#### `pair`
+
+Tests deep link pairing functionality by sending a configuration deep link to the app. This verifies that your app can correctly receive and process pairing deep links containing server connection information.
+
+**Important Distinction:**
+- **Deep linking (this step)**: Used ONLY for initial pairing - sends connection info (server IP, port, auth token) to the app
+- **AgentLink (separate step)**: Used for app commands after pairing - sends commands like `reset_state` via the established WebSocket connection
+
+```yaml
+# Pair with iOS simulator
+- pair: simulator
+  platform: ios
+  timeout: 5000
+
+# Pair with Android emulator
+- pair: emulator
+  platform: android
+  timeout: 5000
+
+# Physical device (requires manual QR scan)
+- pair: physical
+  platform: ios  # or android
+  timeout: 10000
+```
+
+**Parameters:**
+- `pair`: Device type - `simulator`, `emulator`, or `physical`
+- `platform`: Target platform - `ios` or `android` (optional for `physical`)
+- `timeout`: Wait time after sending deep link (default: 5000ms)
+
+**How it works:**
+1. Generates a pairing deep link using the project's configured `--scheme` (from `agenteract.config.js`)
+2. Deep link contains server connection info: `yourapp://agenteract/config?host=localhost&port=8765&token=abc123`
+3. For simulators/emulators: Automatically sends deep link via platform tools (`xcrun simctl openurl` or `adb shell am start`)
+4. For physical devices: Displays the URL (user must manually scan QR code via `pnpm agenteract connect`)
+5. App receives deep link, extracts connection info, and connects to the Agenteract server
+6. Connection config is persisted to device storage (AsyncStorage, SharedPreferences, UserDefaults)
+7. Waits for the specified timeout to allow connection to establish
+
+**Use cases:**
+- **E2E testing of pairing flow**: Verify app correctly handles pairing deep links
+- **CI/CD automation**: Automatically pair simulators/emulators before running tests
+- **Testing fresh app installs**: Simulate first-time pairing experience
+- **Multi-device testing**: Automate pairing of multiple devices in sequence
+
+**Example: Complete Pairing Test**
+```yaml
+project: expo-app
+timeout: 10000
+
+steps:
+  - phase: "Test Pairing Flow"
+  
+  # Send pairing deep link to simulator
+  - pair: simulator
+    platform: ios
+    timeout: 5000
+  
+  # Verify app connected successfully
+  - waitFor: ""
+    logContains: "Connected to Agenteract server"
+    timeout: 3000
+  
+  # Verify app can receive commands (uses WebSocket, not deep links)
+  - agentLink: agenteract://reset_state
+  
+  # Verify reset worked
+  - assert:
+      logContains: "App state cleared"
+```
+
+**Platform Requirements:**
+
+Before using the `pair` step, ensure your app is configured for deep linking:
+
+- **React Native/Expo**: See [Physical Device Setup](#physical-device-setup) for `Info.plist` and `AndroidManifest.xml` configuration
+- **Flutter**: Requires `app_links` package and platform-specific configuration
+- **Swift**: Requires URL scheme in `Info.plist`
+- **Kotlin/Android**: Requires intent filter in `AndroidManifest.xml`
+
+**Troubleshooting:**
+
+If pairing fails:
+1. Check that `--scheme` was provided when running `add-config` (e.g., `--scheme myapp`)
+2. Verify the app's deep link configuration matches the scheme
+3. For simulators/emulators: Ensure device is running and unlocked
+4. For physical devices: Use `pnpm agenteract connect` to generate a QR code
+5. Check app logs for deep link handling errors: `pnpm agenteract-agents logs <project> --since 20`
+
+#### `assert`
+Verifies conditions. Tests fail if assertions don't pass.
+
+```yaml
+# Assert element exists
+- assert:
+    exists: element-testID
+
+# Assert element doesn't exist
+- assert:
+    notExists: element-testID
+
+# Assert element text contains string
+- assert:
+    text:
+      testID: label-testID
+      contains: "Expected text"
+
+# Assert element text equals string
+- assert:
+    text:
+      testID: label-testID
+      equals: "Exact text"
+
+# Assert console log contains string
+- assert:
+    logContains: "Success message"
+```
+
+#### `sleep`
+Pauses execution.
+
+```yaml
+- sleep: 1000  # milliseconds
+```
+
+#### `log`
+Logs a message (visible in test output).
+
+```yaml
+- log: "Starting authentication flow"
+```
+
+#### `phase`
+Groups steps under a labeled phase (for better test organization).
+
+```yaml
+- phase: "Login Phase"
+```
+
+### Test Results
+
+The test runner returns JSON results suitable for CI/CD:
+
+```json
+{
+  "status": "passed",  // or "failed"
+  "duration": 12345,
+  "steps": [
+    {
+      "step": 1,
+      "action": "waitFor",
+      "target": "login-btn",
+      "status": "passed",
+      "duration": 234
+    },
+    {
+      "step": 2,
+      "action": "tap",
+      "target": "login-btn",
+      "status": "passed",
+      "duration": 45
+    }
+  ],
+  "logs": [...],
+  "failedAt": null  // step number if failed
+}
+```
+
+### Example Test Files
+
+**Login Flow Test:**
+```yaml
+project: expo-app
+timeout: 10000
+
+steps:
+  - phase: "Setup"
+  - waitFor: login-button
+    timeout: 5000
+
+  - phase: "Authentication"
+  - input: username-field
+    value: testuser@example.com
+  - input: password-field
+    value: testpass123
+  - tap: login-button
+
+  - phase: "Verification"
+  - waitFor: home-screen
+    timeout: 5000
+  - assert:
+      exists: welcome-message
+  - waitFor: ""
+    logContains: "Login successful"
+    timeout: 3000
+```
+
+**Gesture Test:**
+```yaml
+project: expo-app
+
+steps:
+  - phase: "Scroll Test"
+  - waitFor: scroll-view
+  - scroll: scroll-view
+    direction: down
+    amount: 300
+  - assert:
+      exists: bottom-element
+
+  - phase: "Swipe Test"
+  - waitFor: swipeable-card
+  - swipe: swipeable-card
+    direction: left
+    velocity: fast
+  - assert:
+      notExists: swipeable-card
+```
+
+**AgentLink Reset Test:**
+```yaml
+project: expo-app
+
+steps:
+  - phase: "Setup State"
+  - tap: increment-button
+  - tap: increment-button
+  - input: text-field
+    value: "Some text"
+
+  - phase: "Reset via AgentLink"
+  - agentLink: agenteract://reset_state
+
+  - phase: "Verify Reset"
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+  - assert:
+      text:
+        testID: counter-value
+        equals: "0"
+  - assert:
+      text:
+        testID: text-field-display
+        contains: "Input value: "
+```
+
+### Best Practices
+
+1. **Use phases** to organize test steps logically
+2. **Use `waitFor` with timeouts** instead of arbitrary `sleep` delays
+   - Wait for elements: `waitFor: element-testID` + `timeout: 5000`
+   - Wait for logs: `waitFor: ""` + `logContains: "message"` + `timeout: 3000`
+3. **Use specific assertions** to verify expected behavior
+4. **Keep tests focused** - one test per user flow
+5. **Use meaningful testIDs** that describe the element's purpose
+6. **Test reset states** using deep links between test phases
+7. **Set reasonable timeouts** - achievable under normal conditions, but not so long that failures take forever
diff --git a/examples/expo-example/app.json b/examples/expo-example/app.json
index 35d1a85..e42143b 100644
--- a/examples/expo-example/app.json
+++ b/examples/expo-example/app.json
@@ -5,7 +5,7 @@
     "version": "1.0.0",
     "orientation": "portrait",
     "icon": "./assets/images/icon.png",
-    "scheme": "@agenteract/expo-example",
+    "scheme": "exp",
     "userInterfaceStyle": "automatic",
     "newArchEnabled": true,
     "ios": {
diff --git a/examples/expo-example/app/App.tsx b/examples/expo-example/app/App.tsx
index 08933c2..e063523 100644
--- a/examples/expo-example/app/App.tsx
+++ b/examples/expo-example/app/App.tsx
@@ -4,15 +4,46 @@ import 'react-native-reanimated';
 import { AgentDebugBridge } from '@agenteract/react';
 import { useColorScheme } from '@/hooks/use-color-scheme';
 import HomeScreen from './HomeScreen';
+import { useState, useCallback } from 'react';
+import { parseURL } from './utils/deepLinkUtils';
 
 export default function App() {
   const colorScheme = useColorScheme();
+  const [appState, setAppState] = useState({ username: '', count: 0 });
+
+  const handleAgentLink = useCallback(async (url: string): Promise<boolean> => {
+    console.log('[App] Deep link received:', url);
+
+    try {
+      const { hostname, queryParams } = parseURL(url);
+      console.log('[App] Parsed hostname:', hostname, 'params:', queryParams);
+
+      switch (hostname) {
+        case 'reset_state':
+          console.log('[App] Resetting app state');
+          setAppState({ username: '', count: 0 });
+          console.log('[App] App state cleared');
+          return true;
+
+        case 'reload':
+          console.log('[App] Reload requested via agent link');
+          return true;
+
+        default:
+          console.log('[App] Deep link hostname not handled by app:', hostname);
+          return false;
+      }
+    } catch (error) {
+      console.error('[App] Error parsing agent link in App.tsx:', error);
+      return false;
+    }
+  }, []);
 
   return (
     <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
-      <HomeScreen />
+      <HomeScreen appState={appState} setAppState={setAppState} />
       <StatusBar style="auto" />
-      { __DEV__ && <AgentDebugBridge projectName="expo-app" /> }
+      { __DEV__ && <AgentDebugBridge projectName="expo-app" onAgentLink={handleAgentLink} /> }
     </ThemeProvider>
   );
 }
diff --git a/examples/expo-example/app/HomeScreen.tsx b/examples/expo-example/app/HomeScreen.tsx
index c7a99b9..fd00866 100644
--- a/examples/expo-example/app/HomeScreen.tsx
+++ b/examples/expo-example/app/HomeScreen.tsx
@@ -2,12 +2,26 @@ import { ThemedText } from '@/components/themed-text';
 import { ThemedView } from '@/components/themed-view';
 import { createAgentBinding } from '@agenteract/react';
 import { Pressable, ScrollView, StyleSheet, TextInput, View, PanResponder } from 'react-native';
-import { useState, useRef } from 'react';
+import { useState, useRef, useEffect } from 'react';
 
-export default function HomeScreen() {
-  const [username, setUsername] = useState('');
+interface AppState {
+  username: string;
+  count: number;
+}
+
+interface HomeScreenProps {
+  appState: AppState;
+  setAppState: React.Dispatch<React.SetStateAction<AppState>>;
+}
+
+export default function HomeScreen({ appState, setAppState }: HomeScreenProps) {
   const [cardPosition, setCardPosition] = useState(0);
 
+  // Sync local username state with app state
+  useEffect(() => {
+    console.log('[HomeScreen] App state updated:', appState);
+  }, [appState]);
+
   // Create a PanResponder for the swipeable card
   const panResponder = useRef(
     PanResponder.create({
@@ -31,21 +45,24 @@ export default function HomeScreen() {
       <ThemedText type="title">Home</ThemedText>
         <Pressable {...createAgentBinding({
             testID: 'test-button',
-            onPress: () => console.log('Simulate button pressed'),
+            onPress: () => {
+              console.log('Simulate button pressed');
+              setAppState(prev => ({ ...prev, count: prev.count + 1 }));
+            },
           })}
         >
-          <ThemedText>Simulate Target</ThemedText>
+          <ThemedText>Simulate Target (Count: {appState.count})</ThemedText>
         </Pressable>
 
         <View style={styles.textInputContainer}>
           <TextInput
           // onChangeText={(text) => {console.log('Simulate text input:', text); setUsername(text);}}
           placeholder="Enter username"
-          value={username}
+          value={appState.username}
           style={styles.textInput}
           {...createAgentBinding({
             testID: 'username-input',
-            onChangeText: (text) => setUsername(text),
+            onChangeText: (text) => setAppState(prev => ({ ...prev, username: text })),
           })}
            />
         </View>
diff --git a/examples/expo-example/app/utils/deepLinkUtils.ts b/examples/expo-example/app/utils/deepLinkUtils.ts
new file mode 100644
index 0000000..b6e0049
--- /dev/null
+++ b/examples/expo-example/app/utils/deepLinkUtils.ts
@@ -0,0 +1,30 @@
+/**
+ * Parse an agentLink URL and extract hostname and query parameters
+ * 
+ * For agentLink, we use simple top-level routes:
+ * - agenteract://reset_state
+ * - agenteract://reload
+ * - agenteract://navigate?screen=settings
+ * 
+ * The URL.hostname gives us the route name directly.
+ */
+export function parseURL(url: string): { hostname: string; queryParams: Record<string, string> } {
+  try {
+    const parsed = new URL(url);
+    
+    // For agentLink URLs like agenteract://reset_state
+    // the hostname is the route name
+    const hostname = parsed.hostname || parsed.pathname.split('/').filter(Boolean)[0] || '';
+    
+    // Extract query parameters
+    const queryParams: Record<string, string> = {};
+    parsed.searchParams.forEach((value, key) => {
+      queryParams[key] = value;
+    });
+    
+    return { hostname, queryParams };
+  } catch (error) {
+    console.error('[deepLinkUtils] Failed to parse URL:', error);
+    return { hostname: '', queryParams: {} };
+  }
+}
diff --git a/examples/flutter_example/ios/Runner/AppDelegate.swift b/examples/flutter_example/ios/Runner/AppDelegate.swift
index 6266644..b35a79e 100644
--- a/examples/flutter_example/ios/Runner/AppDelegate.swift
+++ b/examples/flutter_example/ios/Runner/AppDelegate.swift
@@ -10,4 +10,8 @@ import UIKit
     GeneratedPluginRegistrant.register(with: self)
     return super.application(application, didFinishLaunchingWithOptions: launchOptions)
   }
+
+  override func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
+    return super.application(app, open: url, options: options)
+  }
 }
diff --git a/examples/flutter_example/lib/main.dart b/examples/flutter_example/lib/main.dart
index 6d65db2..73e0c3f 100644
--- a/examples/flutter_example/lib/main.dart
+++ b/examples/flutter_example/lib/main.dart
@@ -9,6 +9,33 @@ void main() {
 class MyApp extends StatelessWidget {
   const MyApp({super.key});
 
+  // Handle agent links from Agenteract
+  Future<bool> _handleAgentLink(String url) async {
+    debugPrint('[MyApp] Agent link received: $url');
+    try {
+      final uri = Uri.parse(url);
+      debugPrint(
+          '[MyApp] Parsed URI: scheme=${uri.scheme}, host=${uri.host}, path=${uri.path}');
+
+      // Handle agentLink routes by hostname
+      // For example: agenteract://reset_state
+      if (uri.host == 'reset_state') {
+        debugPrint('[MyApp] Resetting app state via agent link');
+        debugPrint('App state cleared');
+        // Signal MyHomePage to reset (we'll use a ValueNotifier for this)
+        _resetNotifier.value = DateTime.now().millisecondsSinceEpoch;
+        return true;
+      }
+
+      debugPrint('[MyApp] Agent link not handled by app');
+      // Let AgentDebugBridge handle other links (like config)
+      return false;
+    } catch (e) {
+      debugPrint('[MyApp] Error handling agent link: $e');
+      return false;
+    }
+  }
+
   // This widget is the root of your application.
   @override
   Widget build(BuildContext context) {
@@ -32,6 +59,7 @@ class MyApp extends StatelessWidget {
     if (kDebugMode) {
       return AgentDebugBridge(
         projectName: 'flutter-example',
+        onAgentLink: _handleAgentLink,
         child: app,
       );
     }
@@ -39,6 +67,9 @@ class MyApp extends StatelessWidget {
   }
 }
 
+// Global notifier for reset events
+final _resetNotifier = ValueNotifier<int>(0);
+
 class MyHomePage extends StatefulWidget {
   const MyHomePage({super.key, required this.title});
 
@@ -72,10 +103,18 @@ class _MyHomePageState extends State<MyHomePage> {
     // Track scroll position for agent commands
     _horizontalScrollController.trackForAgent('horizontal-scroll');
     _verticalScrollController.trackForAgent('main-list');
+
+    // Listen for reset events from agent links
+    _resetNotifier.addListener(_onReset);
+  }
+
+  void _onReset() {
+    _resetAll();
   }
 
   @override
   void dispose() {
+    _resetNotifier.removeListener(_onReset);
     _textController.dispose();
     _horizontalScrollController.dispose();
     _verticalScrollController.dispose();
diff --git a/examples/kmp-example/src/androidMain/AndroidManifest.xml b/examples/kmp-example/src/androidMain/AndroidManifest.xml
index 46d2ef4..8d8c44a 100644
--- a/examples/kmp-example/src/androidMain/AndroidManifest.xml
+++ b/examples/kmp-example/src/androidMain/AndroidManifest.xml
@@ -12,6 +12,7 @@
             android:name=".MainActivity"
             android:exported="true"
             android:label="Agenteract KMP"
+            android:launchMode="singleTask"
             android:theme="@android:style/Theme.Material.Light.NoActionBar">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
@@ -28,6 +29,14 @@
                     android:host="agenteract"
                     android:pathPrefix="/config" />
             </intent-filter>
+            <!-- App-specific deep links -->
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.BROWSABLE" />
+
+                <data android:scheme="agenteract-kmp-example" />
+            </intent-filter>
         </activity>
     </application>
 </manifest>
diff --git a/examples/kmp-example/src/androidMain/kotlin/io/agenteract/kmp_example/MainActivity.kt b/examples/kmp-example/src/androidMain/kotlin/io/agenteract/kmp_example/MainActivity.kt
index fb83b9b..fdc5e00 100644
--- a/examples/kmp-example/src/androidMain/kotlin/io/agenteract/kmp_example/MainActivity.kt
+++ b/examples/kmp-example/src/androidMain/kotlin/io/agenteract/kmp_example/MainActivity.kt
@@ -1,6 +1,5 @@
 package io.agenteract.kmp_example
 
-import App
 import android.content.Intent
 import android.os.Bundle
 import androidx.activity.ComponentActivity
@@ -15,7 +14,7 @@ class MainActivity : ComponentActivity() {
         // Initialize Agenteract context
         AgenteractContext.appContext = applicationContext
 
-        // Handle deep link if present
+        // Handle deep link for device pairing/configuration only
         DeepLinkHandler.handleIntent(intent)
 
         setContent {
@@ -25,7 +24,7 @@ class MainActivity : ComponentActivity() {
 
     override fun onNewIntent(intent: Intent) {
         super.onNewIntent(intent)
-        // Handle deep links when app is already running
+        // Handle deep links for device pairing/configuration when app is already running
         DeepLinkHandler.handleIntent(intent)
     }
 }
diff --git a/examples/kmp-example/src/commonMain/kotlin/App.kt b/examples/kmp-example/src/commonMain/kotlin/App.kt
index 121b4d1..c65e0e1 100644
--- a/examples/kmp-example/src/commonMain/kotlin/App.kt
+++ b/examples/kmp-example/src/commonMain/kotlin/App.kt
@@ -1,3 +1,5 @@
+package io.agenteract.kmp_example
+
 import androidx.compose.foundation.background
 import androidx.compose.foundation.gestures.detectTapGestures
 import androidx.compose.foundation.gestures.scrollBy
@@ -28,6 +30,7 @@ import androidx.compose.material.TopAppBar
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.filled.Add
 import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
 import androidx.compose.runtime.remember
@@ -49,13 +52,18 @@ import kotlinx.coroutines.launch
 @Composable
 fun App() {
     MaterialTheme {
+        val coroutineScope = rememberCoroutineScope()
+        
+        // State management
         var counter by remember { mutableStateOf(0) }
         var inputText by remember { mutableStateOf("") }
         var longPressCount by remember { mutableStateOf(0) }
         var swipeCount by remember { mutableStateOf(0) }
         var lastSwipeDirection by remember { mutableStateOf("") }
         
-        val coroutineScope = rememberCoroutineScope()
+        val verticalScrollState = rememberScrollState()
+        val horizontalListState = rememberLazyListState()
+        val verticalListState = rememberLazyListState()
         
         fun log(message: String) {
             coroutineScope.launch {
@@ -63,12 +71,35 @@ fun App() {
             }
         }
         
-        val verticalScrollState = rememberScrollState()
-        val horizontalListState = rememberLazyListState()
-        val verticalListState = rememberLazyListState()
+        fun resetAll() {
+            counter = 0
+            inputText = ""
+            longPressCount = 0
+            swipeCount = 0
+            lastSwipeDirection = ""
+            coroutineScope.launch {
+                horizontalListState.scrollToItem(0)
+            }
+            log("All values reset")
+        }
 
         // Initialize the Agent Debug Bridge
-        AgentDebugBridge(projectName = "kmp-app")
+        AgentDebugBridge(
+            projectName = "kmp-app",
+            onAgentLink = { url ->
+                // Parse agentLink URL by hostname
+                // For example: agenteract://reset_state
+                val hostname = url.substringAfter("://").substringBefore("?").substringBefore("/")
+                when (hostname) {
+                    "reset_state" -> {
+                        resetAll()
+                        coroutineScope.launch {
+                            AgentLogger.log("App state cleared")
+                        }
+                    }
+                }
+            }
+        )
 
         Scaffold(
             topBar = {
@@ -302,32 +333,12 @@ fun App() {
                 // Reset Button
                 Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                     Button(
-                        onClick = {
-                            counter = 0
-                            inputText = ""
-                            longPressCount = 0
-                            swipeCount = 0
-                            lastSwipeDirection = ""
-                            coroutineScope.launch {
-                                horizontalListState.scrollToItem(0)
-                            }
-                            log("All values reset")
-                        },
+                        onClick = { resetAll() },
                         colors = ButtonDefaults.buttonColors(backgroundColor = Color.Red, contentColor = Color.White),
                         modifier = Modifier.agent(
                             testID = "reset-button",
                             type = "Button",
-                            onTap = {
-                                counter = 0
-                                inputText = ""
-                                longPressCount = 0
-                                swipeCount = 0
-                                lastSwipeDirection = ""
-                                coroutineScope.launch {
-                                    horizontalListState.scrollToItem(0)
-                                }
-                                log("All values reset")
-                            }
+                            onTap = { resetAll() }
                         )
                     ) {
                         Text("Reset All")
diff --git a/examples/kmp-example/src/desktopMain/kotlin/Main.kt b/examples/kmp-example/src/desktopMain/kotlin/Main.kt
index 56ae139..e7f3907 100644
--- a/examples/kmp-example/src/desktopMain/kotlin/Main.kt
+++ b/examples/kmp-example/src/desktopMain/kotlin/Main.kt
@@ -1,5 +1,6 @@
 import androidx.compose.ui.window.Window
 import androidx.compose.ui.window.application
+import io.agenteract.kmp_example.App
 
 fun main() = application {
     Window(onCloseRequest = ::exitApplication, title = "Agenteract KMP Example") {
diff --git a/examples/react-example/agenteract.config.js b/examples/react-example/agenteract.config.js
index 1776037..ebe837f 100644
--- a/examples/react-example/agenteract.config.js
+++ b/examples/react-example/agenteract.config.js
@@ -1,11 +1,14 @@
 export default {
-  port: 8766,
-  projects: [
+  "port": 8766,
+  "projects": [
     {
-      name: 'react-app',
-      path: '.',
-      type: 'vite',
-      ptyPort: 8791
+      "name": "react-app",
+      "path": ".",
+      "devServer": {
+        "command": "npm run dev",
+        "port": 8790
+      }
     }
-  ]
-};
+  ],
+  "waitLogTimeout": -1
+};
\ No newline at end of file
diff --git a/examples/react-example/src/App.tsx b/examples/react-example/src/App.tsx
index dd29b3c..6184bb5 100644
--- a/examples/react-example/src/App.tsx
+++ b/examples/react-example/src/App.tsx
@@ -1,5 +1,5 @@
 import { createAgentBinding } from '@agenteract/react';
-import { useState, useRef } from 'react';
+import { useState, useRef, useEffect } from 'react';
 import './App.css';
 
 function App() {
@@ -8,6 +8,18 @@ function App() {
   const touchStartX = useRef(0);
   const touchStartY = useRef(0);
 
+  // Listen for reset events from agentLink
+  useEffect(() => {
+    const handleReset = () => {
+      console.log('[App] Handling reset event');
+      setUsername('');
+      setCardPosition(0);
+    };
+    
+    window.addEventListener('agenteract:reset', handleReset);
+    return () => window.removeEventListener('agenteract:reset', handleReset);
+  }, []);
+
   const handleTouchStart = (e: React.TouchEvent) => {
     touchStartX.current = e.touches[0].clientX;
     touchStartY.current = e.touches[0].clientY;
diff --git a/examples/react-example/src/main.tsx b/examples/react-example/src/main.tsx
index 3f7037a..f1a6b8f 100644
--- a/examples/react-example/src/main.tsx
+++ b/examples/react-example/src/main.tsx
@@ -4,10 +4,41 @@ import './index.css'
 import App from './App.tsx'
 import { AgentDebugBridge } from '@agenteract/react'
 
+// Handler for agentLink from tests
+const handleAgentLink = async (url: string): Promise<boolean> => {
+  console.log('[AgentLink] Received:', url);
+  
+  try {
+    const uri = new URL(url);
+    const action = uri.hostname || uri.pathname.replace('/', '');
+    
+    switch (action) {
+      case 'reset_state':
+        console.log('[AgentLink] Resetting app state');
+        // Dispatch custom event to reset app
+        window.dispatchEvent(new CustomEvent('agenteract:reset'));
+        console.log('App state cleared');
+        return true;
+      
+      case 'navigate':
+        const screen = uri.searchParams.get('screen');
+        console.log(`[AgentLink] Navigate to screen: ${screen}`);
+        return true;
+      
+      default:
+        console.log('[AgentLink] Unknown action:', action);
+        return false;
+    }
+  } catch (error) {
+    console.error('[AgentLink] Error handling agent link:', error);
+    return false;
+  }
+};
+
 createRoot(document.getElementById('root')!).render(
   <StrictMode>
     <>
-    <AgentDebugBridge projectName="react-app" />
+    <AgentDebugBridge projectName="react-app" onAgentLink={handleAgentLink} />
     <App />
     </>
   </StrictMode>,
diff --git a/examples/swift-app/AgenteractSwiftExample/AgenteractSwiftExample/ContentView.swift b/examples/swift-app/AgenteractSwiftExample/AgenteractSwiftExample/ContentView.swift
index f45ac4f..125c513 100644
--- a/examples/swift-app/AgenteractSwiftExample/AgenteractSwiftExample/ContentView.swift
+++ b/examples/swift-app/AgenteractSwiftExample/AgenteractSwiftExample/ContentView.swift
@@ -14,6 +14,17 @@ struct ContentView: View {
     @State private var longPressCount = 0
     @State private var cardOffset: CGFloat = 0
     @State private var swipeCount = 0
+    @State private var resetTrigger = 0 // Used to trigger reset from agent link
+
+    // Reset all state
+    func resetAllState() {
+        tapCount = 0
+        inputText = ""
+        longPressCount = 0
+        swipeCount = 0
+        cardOffset = 0
+        AppLogger.info("App state cleared")
+    }
 
     var body: some View {
         ScrollView {
@@ -279,6 +290,7 @@ struct ContentView: View {
                     longPressCount = 0
                     swipeCount = 0
                     cardOffset = 0
+                    AppLogger.info("All values reset")
                 })
                 .padding()
                 .background(Color.red)
@@ -287,10 +299,23 @@ struct ContentView: View {
             }
             .padding()
         }
-        // Add the AgentDebugBridge
+        // Add the AgentDebugBridge with deep link handler
         .background(
-            AgentDebugBridge(projectName: "swift-app")
+            AgentDebugBridge(projectName: "swift-app") { url in
+                // Handle agentLink routes by hostname
+                // For example: agenteract://reset_state
+                if url.host == "reset_state" {
+                    resetAllState()
+                    return true
+                }
+                // Let AgentDebugBridge handle config links
+                return false
+            }
         )
+        .onChange(of: resetTrigger) { _ in
+            // This allows external triggers to reset state if needed
+            resetAllState()
+        }
     }
 }
 
diff --git a/packages/agents/package.json b/packages/agents/package.json
index b749b7d..6949c1f 100644
--- a/packages/agents/package.json
+++ b/packages/agents/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@agenteract/agents",
-  "version": "0.1.5",
+  "version": "0.1.2",
   "description": "Agent tools for Agenteract",
   "type": "module",
   "main": "dist/cli.js",
@@ -35,6 +35,7 @@
     "@agenteract/core": "workspace:*",
     "axios": "^1.7.2",
     "glob": "^10.5.0",
+    "yaml": "^2.3.4",
     "yargs": "^17.7.2"
   },
   "devDependencies": {
diff --git a/packages/agents/src/cli.ts b/packages/agents/src/cli.ts
index d8d9e32..17e8ab7 100644
--- a/packages/agents/src/cli.ts
+++ b/packages/agents/src/cli.ts
@@ -3,6 +3,7 @@ import yargs from 'yargs';
 
 import { hideBin } from 'yargs/helpers';
 import axios from 'axios';
+import YAML from 'yaml';
 
 import fs from 'fs';
 import path from 'path';
@@ -845,6 +846,126 @@ yargs(hideBin(process.argv))
       }
     }
   )
+  .command(
+    'test <file>',
+    'Run a YAML test file',
+    (yargs) => {
+      return yargs
+        .positional('file', {
+          describe: 'Path to YAML test file',
+          type: 'string',
+          demandOption: true,
+        })
+        .option('project', {
+          alias: 'p',
+          type: 'string',
+          description: 'Override project name from test file',
+        })
+        .option('device', {
+          alias: 'd',
+          type: 'string',
+          description: 'Override device from test file',
+        })
+        .option('runtime-target', {
+          alias: 't',
+          type: 'string',
+          choices: ['ios', 'android', 'native'],
+          description: 'Runtime target platform (ios, android, or native/desktop)',
+        })
+        .option('verbose', {
+          alias: 'v',
+          type: 'boolean',
+          description: 'Show detailed step output',
+          default: false,
+        })
+        .option('bail', {
+          alias: 'b',
+          type: 'boolean',
+          description: 'Stop on first failure (default behavior)',
+          default: true,
+        });
+    },
+    async (argv) => {
+      try {
+        // Read and parse YAML file
+        const testFilePath = path.resolve(process.cwd(), argv.file);
+        if (!fs.existsSync(testFilePath)) {
+          console.error(`Error: Test file not found: ${testFilePath}`);
+          process.exit(1);
+        }
+
+        const yamlContent = fs.readFileSync(testFilePath, 'utf8');
+        const testDefinition = YAML.parse(yamlContent);
+
+        // Apply CLI overrides
+        if (argv.project) {
+          testDefinition.project = argv.project;
+        }
+        if (argv.device) {
+          testDefinition.device = argv.device;
+        }
+        if (argv.runtimeTarget) {
+          testDefinition.runtimeTarget = argv.runtimeTarget;
+        }
+
+        // Validate required fields
+        if (!testDefinition.project) {
+          console.error('Error: Test definition must include a "project" field');
+          process.exit(1);
+        }
+        if (!testDefinition.steps || !Array.isArray(testDefinition.steps)) {
+          console.error('Error: Test definition must include a "steps" array');
+          process.exit(1);
+        }
+
+        if (argv.verbose) {
+          console.log(`Running test: ${argv.file}`);
+          console.log(`Project: ${testDefinition.project}`);
+          console.log(`Steps: ${testDefinition.steps.length}`);
+          if (testDefinition.device) {
+            console.log(`Device: ${testDefinition.device}`);
+          }
+          console.log('');
+        }
+
+        // Send test definition to server
+        const { agentServerUrl } = await getServerUrls();
+        const response = await axios.post(`${agentServerUrl}/test-run`, testDefinition);
+        const result = response.data;
+
+        // Output JSON for CI tools
+        const output = JSON.stringify(result, null, 2);
+
+        // Show summary if verbose
+        if (argv.verbose) {
+          console.log(output);
+          console.log('');
+          console.log('='.repeat(60));
+          console.log(`Test ${result.status === 'passed' ? 'PASSED' : 'FAILED'}`);
+          console.log(`Duration: ${result.duration}ms`);
+          console.log(`Steps: ${result.steps.filter((s: any) => s.status === 'passed').length}/${result.steps.length} passed`);
+          if (result.failedAt) {
+            console.log(`Failed at step: ${result.failedAt}`);
+          }
+          console.log('='.repeat(60));
+        } else {
+          // wait for write() callback to complete - large buffers can cause truncation
+          await new Promise<void>(resolve =>
+            process.stdout.write(output + '\n', (e) => {
+              if (e) {
+                console.error('Error writing output:', e);
+                process.exit(1);
+              }
+              resolve();
+              process.exit(result.status === 'passed' ? 0 : 1);
+            }));
+        }
+      } catch (error) {
+        handleRequestError(error);
+        process.exit(1);
+      }
+    }
+  )
   .strictCommands()
   .demandCommand(1, 'You must provide a valid command.')
   .help()
diff --git a/packages/agents/tests/wait-log-timeout.test.ts b/packages/agents/tests/wait-log-timeout.test.ts
index 5509cf9..42f5f21 100644
--- a/packages/agents/tests/wait-log-timeout.test.ts
+++ b/packages/agents/tests/wait-log-timeout.test.ts
@@ -163,7 +163,8 @@ describe('waitLogTimeout functionality', () => {
       await waitAndFetchLogs(agentServerUrl, project, 50, logCount); // Explicit 50ms
       
       const elapsed = Date.now() - startTime;
-      expect(elapsed).toBeGreaterThanOrEqual(50);
+      // Allow small timing tolerance (45ms) to account for system timer resolution
+      expect(elapsed).toBeGreaterThanOrEqual(45);
       expect(elapsed).toBeLessThan(200); // Should not use config's 1000ms
       expect(mockAxios.get).toHaveBeenCalledWith(
         `${agentServerUrl}/logs?project=${project}&since=${logCount}`
@@ -177,7 +178,8 @@ describe('waitLogTimeout functionality', () => {
       await waitAndFetchLogs(agentServerUrl, project, undefined, logCount);
       
       const elapsed = Date.now() - startTime;
-      expect(elapsed).toBeGreaterThanOrEqual(100);
+      // Allow small timing tolerance (95ms) to account for system timer resolution
+      expect(elapsed).toBeGreaterThanOrEqual(95);
       expect(mockAxios.get).toHaveBeenCalled();
     });
 
@@ -227,7 +229,8 @@ describe('waitLogTimeout functionality', () => {
       await waitAndFetchLogs(agentServerUrl, project, waitTime, logCount);
       
       const elapsed = Date.now() - startTime;
-      expect(elapsed).toBeGreaterThanOrEqual(waitTime);
+      // Allow small timing tolerance (95ms) to account for system timer resolution
+      expect(elapsed).toBeGreaterThanOrEqual(95);
       expect(mockAxios.get).toHaveBeenCalled();
     });
 
@@ -259,7 +262,8 @@ describe('waitLogTimeout functionality', () => {
       await waitAndFetchLogs(agentServerUrl, project, undefined, logCount);
       
       const elapsed = Date.now() - startTime;
-      expect(elapsed).toBeGreaterThanOrEqual(500);
+      // Allow small timing tolerance (495ms) to account for system timer resolution
+      expect(elapsed).toBeGreaterThanOrEqual(495);
       expect(mockAxios.get).toHaveBeenCalled();
       expect(consoleWarnMock).toHaveBeenCalled(); // Should show deprecation warning
     });
diff --git a/packages/core/__mocks__/puppeteer.js b/packages/core/__mocks__/puppeteer.js
new file mode 100644
index 0000000..67cd0a5
--- /dev/null
+++ b/packages/core/__mocks__/puppeteer.js
@@ -0,0 +1,18 @@
+// Manual mock for puppeteer to support dynamic import testing
+const mockBrowser = {
+  newPage: jest.fn().mockResolvedValue({
+    goto: jest.fn().mockResolvedValue(undefined),
+  }),
+  close: jest.fn().mockResolvedValue(undefined),
+};
+
+const mockLaunch = jest.fn().mockResolvedValue(mockBrowser);
+
+module.exports = {
+  launch: mockLaunch,
+  default: {
+    launch: mockLaunch,
+  },
+  __mockBrowser: mockBrowser,
+  __mockLaunch: mockLaunch,
+};
diff --git a/packages/core/jest.config.cjs b/packages/core/jest.config.cjs
new file mode 100644
index 0000000..305d47c
--- /dev/null
+++ b/packages/core/jest.config.cjs
@@ -0,0 +1,9 @@
+/** @type {import('ts-jest').JestConfigWithTsJest} */
+module.exports = {
+  preset: 'ts-jest',
+  testEnvironment: 'node',
+  testPathIgnorePatterns: ['/node_modules/', '/dist/'],
+  moduleNameMapper: {
+    '^(\\.{1,2}/.*)\\.js$': '$1',
+  },
+};
diff --git a/packages/core/package.json b/packages/core/package.json
index cb005b6..6253b8e 100644
--- a/packages/core/package.json
+++ b/packages/core/package.json
@@ -33,7 +33,8 @@
     "build:cjs": "tsc -p tsconfig.cjs.json",
     "build:esm": "tsc -p tsconfig.esm.json",
     "build:post": "shx mkdir -p dist/cjs dist/esm && node ../../scripts/write-package-json.js commonjs dist/cjs/package.json && node ../../scripts/write-package-json.js module dist/esm/package.json",
-    "clean": "shx rm -rf dist .tsbuildinfo*"
+    "clean": "shx rm -rf dist .tsbuildinfo*",
+    "test": "jest --config jest.config.cjs"
   },
   "exports": {
     ".": {
@@ -50,6 +51,10 @@
   },
   "license": "Apache-2.0",
   "devDependencies": {
+    "@types/jest": "^29.5.14",
+    "@types/node": "^22.10.2",
+    "jest": "^29.7.0",
+    "ts-jest": "^29.2.5",
     "typescript": "^5.6.0"
   }
 }
diff --git a/packages/core/src/config-types.ts b/packages/core/src/config-types.ts
index 9715720..e35aedd 100644
--- a/packages/core/src/config-types.ts
+++ b/packages/core/src/config-types.ts
@@ -22,6 +22,16 @@ export interface ProjectConfig {
   devServer?: DevServerConfig;
   // Optional: URL scheme for deep linking (e.g., 'myapp')
   scheme?: string;
+  // Optional: app lifecycle configuration overrides
+  lifecycle?: {
+    bundleId?: {
+      ios?: string;
+      android?: string;
+    };
+    mainActivity?: string;
+    launchTimeout?: number;
+    requiresInstall?: boolean;
+  };
 }
 
 export interface AgenteractConfig {
diff --git a/packages/core/src/node/app-launcher.test.ts b/packages/core/src/node/app-launcher.test.ts
new file mode 100644
index 0000000..8411ece
--- /dev/null
+++ b/packages/core/src/node/app-launcher.test.ts
@@ -0,0 +1,467 @@
+const mockExecFileAsync = jest.fn();
+const mockSpawn = jest.fn();
+
+// Mock modules before imports
+jest.mock('child_process', () => ({
+  execFile: jest.fn(),
+  spawn: mockSpawn,
+}));
+
+jest.mock('util', () => ({
+  promisify: jest.fn(() => mockExecFileAsync),
+}));
+
+// Use manual mock for puppeteer (in __mocks__/puppeteer.js)
+jest.mock('puppeteer');
+
+import {
+  launchApp,
+  stopApp,
+  buildApp,
+  performSetup,
+} from './app-launcher';
+
+describe('app-launcher', () => {
+  beforeEach(() => {
+    jest.clearAllMocks();
+  });
+
+  describe('launchApp', () => {
+    it('should launch Vite web app with Puppeteer', async () => {
+      const puppeteer = require('puppeteer');
+      const mockLaunch = puppeteer.default.launch as jest.Mock;
+      const result = await launchApp('vite', null, {}, '/test/vite-app');
+
+      expect(mockLaunch).toHaveBeenCalledWith(
+        expect.objectContaining({
+          headless: true,
+          args: expect.arrayContaining(['--no-sandbox']),
+        })
+      );
+      expect(result.browser).toBeDefined();
+    });
+
+    it('should launch iOS app on simulator', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = {
+        id: 'ABC-123',
+        name: 'iPhone 15',
+        type: 'ios' as const,
+        state: 'booted' as const,
+      };
+      const bundleInfo = { ios: 'com.example.app' };
+
+      const result = await launchApp('flutter', device, bundleInfo, '/test/flutter-app');
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'xcrun',
+        ['simctl', 'launch', 'ABC-123', 'com.example.app'],
+        expect.any(Object)
+      );
+      expect(result).toEqual({});
+    });
+
+    it('should boot iOS simulator if not booted', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = {
+        id: 'ABC-123',
+        name: 'iPhone 15',
+        type: 'ios' as const,
+        state: 'shutdown' as const,
+      };
+      const bundleInfo = { ios: 'com.example.app' };
+
+      await launchApp('flutter', device, bundleInfo, '/test/flutter-app');
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'xcrun',
+        ['simctl', 'boot', 'ABC-123']
+      );
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'xcrun',
+        ['simctl', 'launch', 'ABC-123', 'com.example.app'],
+        expect.objectContaining({ timeout: 60000 })
+      );
+    }, 10000);
+
+    it('should launch Android app with port forwarding', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = {
+        id: 'emulator-5554',
+        name: 'Pixel 5',
+        type: 'android' as const,
+        state: 'booted' as const,
+      };
+      const bundleInfo = {
+        android: 'com.example.app',
+        androidMainActivity: 'MainActivity',
+      };
+
+      await launchApp('flutter', device, bundleInfo, '/test/flutter-app');
+
+      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
+        1,
+        'adb',
+        ['-s', 'emulator-5554', 'reverse', 'tcp:8765', 'tcp:8765']
+      );
+      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
+        2,
+        'adb',
+        ['-s', 'emulator-5554', 'shell', 'am', 'start', '-n', 'com.example.app/.MainActivity', '-W'],
+        expect.objectContaining({ timeout: 60000 })
+      );
+    });
+
+    it('should handle port forwarding failure gracefully', async () => {
+      mockExecFileAsync
+        .mockRejectedValueOnce(new Error('Port forwarding failed'))
+        .mockResolvedValueOnce({ stdout: '', stderr: '' } as any);
+
+      const device = {
+        id: 'emulator-5554',
+        name: 'Pixel 5',
+        type: 'android' as const,
+        state: 'booted' as const,
+      };
+      const bundleInfo = {
+        android: 'com.example.app',
+        androidMainActivity: 'MainActivity',
+      };
+
+      await launchApp('flutter', device, bundleInfo, '/test/flutter-app');
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'adb',
+        expect.arrayContaining(['shell', 'am', 'start']),
+        expect.objectContaining({ timeout: 60000 })
+      );
+    });
+
+    it('should launch KMP desktop app via gradle', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: 'run - Run app\nrunDebug - Run debug', stderr: '' } as any);
+      mockSpawn.mockReturnValue({
+        on: jest.fn(),
+        kill: jest.fn(),
+      } as any);
+
+      const result = await launchApp('kmp-desktop', null, {}, '/test/kmp-app');
+
+      expect(mockSpawn).toHaveBeenCalledWith(
+        './gradlew',
+        ['run', '--quiet'],
+        expect.objectContaining({ cwd: '/test/kmp-app' })
+      );
+      expect(result.process).toBeDefined();
+    });
+
+    it('should use default run task if gradle task detection fails', async () => {
+      mockExecFileAsync.mockRejectedValue(new Error('Gradle failed'));
+      mockSpawn.mockReturnValue({
+        on: jest.fn(),
+        kill: jest.fn(),
+      } as any);
+
+      await launchApp('kmp-desktop', null, {}, '/test/kmp-app');
+
+      expect(mockSpawn).toHaveBeenCalledWith(
+        './gradlew',
+        ['run', '--quiet'],
+        expect.any(Object)
+      );
+    });
+
+    it('should throw error if no device available for mobile platform', async () => {
+      await expect(
+        launchApp('flutter', null, {}, '/test/flutter-app')
+      ).rejects.toThrow('No device available');
+    });
+
+    it('should throw error for unsupported platform', async () => {
+      await expect(
+        launchApp('unsupported' as any, null, {}, '/test/app')
+      ).rejects.toThrow('Unsupported platform');
+    });
+  });
+
+  describe('stopApp', () => {
+    it('should close Puppeteer browser for Vite', async () => {
+      const puppeteer = require('puppeteer');
+      const mockLaunch = puppeteer.default.launch as jest.Mock;
+      const mockBrowser = await mockLaunch();
+      const launchResult = { browser: mockBrowser };
+
+      await stopApp('vite', null, {}, launchResult, false);
+
+      expect(mockBrowser.close).toHaveBeenCalled();
+    });
+
+    it('should terminate iOS app gracefully', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'ABC-123', name: 'iPhone 15', type: 'ios' as const };
+      const bundleInfo = { ios: 'com.example.app' };
+
+      await stopApp('flutter', device, bundleInfo, {}, false);
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'xcrun',
+        ['simctl', 'terminate', 'ABC-123', 'com.example.app']
+      );
+    });
+
+    it('should stop Android app gracefully', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'emulator-5554', name: 'Pixel 5', type: 'android' as const };
+      const bundleInfo = { android: 'com.example.app' };
+
+      await stopApp('kmp-android', device, bundleInfo, {}, false);
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'adb',
+        ['-s', 'emulator-5554', 'shell', 'am', 'stop', 'com.example.app']
+      );
+    });
+
+    it('should force stop Android app', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'emulator-5554', name: 'Pixel 5', type: 'android' as const };
+      const bundleInfo = { android: 'com.example.app' };
+
+      await stopApp('kmp-android', device, bundleInfo, {}, true);
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'adb',
+        ['-s', 'emulator-5554', 'shell', 'am', 'force-stop', 'com.example.app']
+      );
+    });
+
+    it('should kill desktop app process', async () => {
+      const mockProcess = { kill: jest.fn() };
+      const launchResult = { process: mockProcess as any };
+
+      await stopApp('kmp-desktop', null, {}, launchResult, false);
+
+      expect(mockProcess.kill).toHaveBeenCalledWith('SIGTERM');
+    });
+
+    it('should force kill desktop app process', async () => {
+      const mockProcess = { kill: jest.fn() };
+      const launchResult = { process: mockProcess as any };
+
+      await stopApp('kmp-desktop', null, {}, launchResult, true);
+
+      expect(mockProcess.kill).toHaveBeenCalledWith('SIGKILL');
+    });
+
+    it('should handle stop errors gracefully', async () => {
+      mockExecFileAsync.mockRejectedValue(new Error('Stop failed'));
+
+      const device = { id: 'ABC-123', name: 'iPhone 15', type: 'ios' as const };
+      const bundleInfo = { ios: 'com.example.app' };
+
+      await expect(
+        stopApp('flutter', device, bundleInfo, {}, false)
+      ).resolves.not.toThrow();
+    });
+  });
+
+  describe('buildApp', () => {
+    it('should build Flutter Android app', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      await buildApp('/test/flutter-app', 'flutter', {
+        configuration: 'debug',
+        platform: 'android',
+      });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        './gradlew',
+        ['assembleDebug'],
+        expect.objectContaining({ cwd: '/test/flutter-app/android' })
+      );
+    });
+
+    it('should build Flutter iOS app', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      await buildApp('/test/flutter-app', 'flutter', {
+        configuration: 'release',
+        platform: 'ios',
+      });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'flutter',
+        ['build', 'ios', '--release'],
+        expect.objectContaining({ cwd: '/test/flutter-app' })
+      );
+    });
+
+    it('should build KMP Android app', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      await buildApp('/test/kmp-app', 'kmp-android', {
+        configuration: 'release',
+      });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        './gradlew',
+        ['assembleRelease'],
+        expect.objectContaining({ cwd: '/test/kmp-app' })
+      );
+    });
+
+    it('should run custom build task for KMP', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      await buildApp('/test/kmp-app', 'kmp-desktop', {
+        configuration: 'customBuildTask',
+      });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        './gradlew',
+        ['customBuildTask'],
+        expect.any(Object)
+      );
+    });
+
+    it('should build Vite app', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      await buildApp('/test/vite-app', 'vite', { configuration: 'debug' });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'npm',
+        ['run', 'build'],
+        expect.objectContaining({ cwd: '/test/vite-app' })
+      );
+    });
+
+    it('should throw error for unsupported Expo builds', async () => {
+      await expect(
+        buildApp('/test/expo-app', 'expo', { configuration: 'debug' })
+      ).rejects.toThrow('Expo builds not yet supported');
+    });
+  });
+
+  describe('performSetup', () => {
+    it('should install Android app via gradle', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'emulator-5554', name: 'Pixel 5', type: 'android' as const };
+
+      await performSetup('/test/flutter-app', 'flutter', device, {}, { action: 'install' });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        './gradlew',
+        ['installDebug'],
+        expect.objectContaining({ cwd: '/test/flutter-app/android' })
+      );
+    });
+
+    it('should install KMP Android app', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'emulator-5554', name: 'Pixel 5', type: 'android' as const };
+
+      await performSetup('/test/kmp-app', 'kmp-android', device, {}, { action: 'install' });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        './gradlew',
+        ['installDebug'],
+        expect.objectContaining({ cwd: '/test/kmp-app' })
+      );
+    });
+
+    it('should skip install for iOS (handled by dev build)', async () => {
+      const device = { id: 'ABC-123', name: 'iPhone 15', type: 'ios' as const };
+
+      await expect(
+        performSetup('/test/flutter-app', 'flutter', device, {}, { action: 'install' })
+      ).resolves.not.toThrow();
+    });
+
+    it('should reinstall Android app', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'emulator-5554', name: 'Pixel 5', type: 'android' as const };
+      const bundleInfo = { android: 'com.example.app' };
+
+      await performSetup('/test/flutter-app', 'flutter', device, bundleInfo, { action: 'reinstall' });
+
+      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
+        1,
+        'adb',
+        ['-s', 'emulator-5554', 'uninstall', 'com.example.app']
+      );
+      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
+        2,
+        './gradlew',
+        ['installDebug'],
+        expect.objectContaining({ cwd: '/test/flutter-app/android' })
+      );
+    });
+
+    it('should clear Android app data', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'emulator-5554', name: 'Pixel 5', type: 'android' as const };
+      const bundleInfo = { android: 'com.example.app' };
+
+      await performSetup('/test/flutter-app', 'flutter', device, bundleInfo, { action: 'clearData' });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'adb',
+        ['-s', 'emulator-5554', 'shell', 'pm', 'clear', 'com.example.app']
+      );
+    });
+
+    it('should clear iOS app data by uninstalling', async () => {
+      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'ABC-123', name: 'iPhone 15', type: 'ios' as const };
+      const bundleInfo = { ios: 'com.example.app' };
+
+      await performSetup('/test/flutter-app', 'flutter', device, bundleInfo, { action: 'clearData' });
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        'xcrun',
+        ['simctl', 'uninstall', 'ABC-123', 'com.example.app']
+      );
+    });
+
+    it('should skip setup if platform filter does not match', async () => {
+      const device = { id: 'ABC-123', name: 'iPhone 15', type: 'ios' as const };
+
+      await performSetup('/test/flutter-app', 'flutter', device, {}, {
+        action: 'install',
+        platform: 'android',
+      });
+
+      expect(mockExecFileAsync).not.toHaveBeenCalled();
+    });
+
+    it('should handle uninstall errors gracefully (app not installed)', async () => {
+      mockExecFileAsync
+        .mockRejectedValueOnce(new Error('App not installed'))
+        .mockResolvedValueOnce({ stdout: '', stderr: '' } as any);
+
+      const device = { id: 'emulator-5554', name: 'Pixel 5', type: 'android' as const };
+      const bundleInfo = { android: 'com.example.app' };
+
+      await expect(
+        performSetup('/test/flutter-app', 'flutter', device, bundleInfo, { action: 'reinstall' })
+      ).resolves.not.toThrow();
+
+      expect(mockExecFileAsync).toHaveBeenCalledWith(
+        './gradlew',
+        ['installDebug'],
+        expect.objectContaining({ cwd: '/test/flutter-app/android' })
+      );
+    });
+  });
+});
diff --git a/packages/core/src/node/app-launcher.ts b/packages/core/src/node/app-launcher.ts
new file mode 100644
index 0000000..d7aa3c9
--- /dev/null
+++ b/packages/core/src/node/app-launcher.ts
@@ -0,0 +1,373 @@
+import { execFile, spawn, ChildProcess } from 'child_process';
+import { promisify } from 'util';
+import { PlatformType } from './platform-detector';
+import { BundleInfo } from './bundle-resolver';
+import { Device } from './device-manager';
+
+const execFileAsync = promisify(execFile);
+
+export interface LaunchResult {
+  browser?: any; // Puppeteer Browser instance for web
+  process?: ChildProcess; // Process for desktop apps
+}
+
+export interface LaunchOptions {
+  timeout?: number;
+  waitForReady?: boolean;
+}
+
+export interface BuildOptions {
+  configuration: 'debug' | 'release' | string;
+  platform?: 'ios' | 'android' | 'desktop' | 'web';
+}
+
+export interface SetupOptions {
+  action: 'install' | 'reinstall' | 'clearData';
+  platform?: 'ios' | 'android';
+}
+
+/**
+ * Launch an app on the target platform
+ */
+export async function launchApp(
+  platformType: PlatformType,
+  device: Device | null,
+  bundleInfo: BundleInfo,
+  projectPath: string,
+  options: LaunchOptions = {}
+): Promise<LaunchResult> {
+  switch (platformType) {
+    case 'vite':
+      return launchWebApp(projectPath, options);
+    case 'flutter':
+    case 'expo':
+    case 'swiftui':
+      if (device?.type === 'ios') {
+        return launchIOSApp(device, bundleInfo.ios!, options);
+      } else if (device?.type === 'android') {
+        return launchAndroidApp(device, bundleInfo.android!, bundleInfo.androidMainActivity!, options);
+      }
+      throw new Error(`No device available for platform ${platformType}`);
+    case 'kmp-android':
+      if (!device || device.type !== 'android') {
+        throw new Error('Android device required for kmp-android platform');
+      }
+      return launchAndroidApp(device, bundleInfo.android!, bundleInfo.androidMainActivity!, options);
+    case 'kmp-desktop':
+      return launchDesktopApp(projectPath, options);
+    default:
+      throw new Error(`Unsupported platform: ${platformType}`);
+  }
+}
+
+/**
+ * Stop a running app
+ */
+export async function stopApp(
+  platformType: PlatformType,
+  device: Device | null,
+  bundleInfo: BundleInfo,
+  launchResult: LaunchResult | undefined,
+  force: boolean = false
+): Promise<void> {
+  switch (platformType) {
+    case 'vite':
+      if (launchResult?.browser) {
+        await launchResult.browser.close();
+      }
+      break;
+    case 'flutter':
+    case 'expo':
+    case 'swiftui':
+      if (device?.type === 'ios' && bundleInfo.ios) {
+        await stopIOSApp(device, bundleInfo.ios);
+      } else if (device?.type === 'android' && bundleInfo.android) {
+        await stopAndroidApp(device, bundleInfo.android, force);
+      }
+      break;
+    case 'kmp-android':
+      if (device && bundleInfo.android) {
+        await stopAndroidApp(device, bundleInfo.android, force);
+      }
+      break;
+    case 'kmp-desktop':
+      if (launchResult?.process) {
+        launchResult.process.kill(force ? 'SIGKILL' : 'SIGTERM');
+      }
+      break;
+  }
+}
+
+/**
+ * Build an app
+ */
+export async function buildApp(
+  projectPath: string,
+  platformType: PlatformType,
+  options: BuildOptions
+): Promise<void> {
+  const { configuration, platform } = options;
+
+  switch (platformType) {
+    case 'flutter':
+      if (platform === 'android') {
+        await execFileAsync('./gradlew', [`assemble${capitalize(configuration)}`], {
+          cwd: `${projectPath}/android`,
+          timeout: 300000,
+        });
+      } else if (platform === 'ios') {
+        // Flutter iOS builds typically done via flutter build ios
+        await execFileAsync('flutter', ['build', 'ios', '--' + configuration.toLowerCase()], {
+          cwd: projectPath,
+          timeout: 300000,
+        });
+      }
+      break;
+    case 'kmp-android':
+    case 'kmp-desktop':
+      if (configuration === 'debug' || configuration === 'release') {
+        await execFileAsync('./gradlew', [`assemble${capitalize(configuration)}`], {
+          cwd: projectPath,
+          timeout: 300000,
+        });
+      } else {
+        // Custom build task
+        await execFileAsync('./gradlew', [configuration], {
+          cwd: projectPath,
+          timeout: 300000,
+        });
+      }
+      break;
+    case 'expo':
+      // Expo builds are typically done via eas-cli or expo build
+      throw new Error('Expo builds not yet supported in app-launcher');
+    case 'vite':
+      // Vite builds typically via npm run build
+      await execFileAsync('npm', ['run', 'build'], {
+        cwd: projectPath,
+        timeout: 300000,
+      });
+      break;
+    default:
+      throw new Error(`Build not supported for platform: ${platformType}`);
+  }
+}
+
+/**
+ * Perform setup actions (install, reinstall, clearData)
+ */
+export async function performSetup(
+  projectPath: string,
+  platformType: PlatformType,
+  device: Device | null,
+  bundleInfo: BundleInfo,
+  options: SetupOptions
+): Promise<void> {
+  const { action, platform } = options;
+
+  // Skip if platform filter doesn't match
+  if (platform && device?.type !== platform) {
+    return;
+  }
+
+  switch (action) {
+    case 'install':
+      await installApp(projectPath, platformType, device, bundleInfo);
+      break;
+    case 'reinstall':
+      await uninstallApp(platformType, device, bundleInfo);
+      await installApp(projectPath, platformType, device, bundleInfo);
+      break;
+    case 'clearData':
+      await clearAppData(platformType, device, bundleInfo);
+      break;
+  }
+}
+
+// --- Platform-specific implementations ---
+
+async function launchWebApp(projectPath: string, options: LaunchOptions): Promise<LaunchResult> {
+  // For Vite apps, assume dev server is already running
+  // Launch Puppeteer browser
+  let puppeteer;
+  try {
+    puppeteer = await import('puppeteer');
+  } catch (error) {
+    throw new Error('Puppeteer not installed. Install with: npm install puppeteer');
+  }
+
+  const launcher = puppeteer.default || puppeteer;
+  const browser = await launcher.launch({
+    headless: true,
+    args: [
+      '--no-sandbox',
+      '--disable-setuid-sandbox',
+      '--disable-web-security',
+      '--disable-features=IsolateOrigins,site-per-process',
+    ],
+  });
+
+  const page = await browser.newPage();
+  await page.goto('http://localhost:5173', {
+    waitUntil: 'networkidle0',
+    timeout: options.timeout || 60000,
+  });
+
+  return { browser };
+}
+
+async function launchIOSApp(device: Device, bundleId: string, options: LaunchOptions): Promise<LaunchResult> {
+  // Boot simulator if needed
+  if (device.state !== 'booted') {
+    await execFileAsync('xcrun', ['simctl', 'boot', device.id]);
+    // Wait a bit for boot to complete
+    await new Promise(resolve => setTimeout(resolve, 5000));
+  }
+
+  // Launch app
+  await execFileAsync('xcrun', ['simctl', 'launch', device.id, bundleId], {
+    timeout: options.timeout || 60000,
+  });
+
+  return {};
+}
+
+async function launchAndroidApp(
+  device: Device,
+  bundleId: string,
+  mainActivity: string,
+  options: LaunchOptions
+): Promise<LaunchResult> {
+  // Set up port forwarding for AgentDebugBridge
+  try {
+    await execFileAsync('adb', ['-s', device.id, 'reverse', 'tcp:8765', 'tcp:8765']);
+  } catch (error) {
+    console.warn('Port forwarding failed, app may not connect:', error);
+  }
+
+  // Launch app
+  // mainActivity can be either a full class name (com.example.MainActivity) or relative (.MainActivity)
+  // If it already starts with bundleId, use it as-is; otherwise prefix with '.'
+  const activityName = mainActivity.startsWith(bundleId) 
+    ? mainActivity 
+    : (mainActivity.startsWith('.') ? mainActivity : `.${mainActivity}`);
+  const componentName = `${bundleId}/${activityName}`;
+  await execFileAsync(
+    'adb',
+    ['-s', device.id, 'shell', 'am', 'start', '-n', componentName, '-W'],
+    { timeout: options.timeout || 60000 }
+  );
+
+  return {};
+}
+
+async function launchDesktopApp(projectPath: string, options: LaunchOptions): Promise<LaunchResult> {
+  // Detect available gradle tasks
+  let runTask = 'run';
+  try {
+    const { stdout } = await execFileAsync('./gradlew', ['tasks', '--console=plain'], {
+      cwd: projectPath,
+      timeout: 30000,
+    });
+
+    // Find first run task
+    const taskLines = stdout.split('\n');
+    const runTasks = taskLines
+      .filter(line => line.match(/^(run|runDebug|desktopRun)\b/))
+      .map(line => line.split(' ')[0].trim());
+
+    if (runTasks.length > 0) {
+      runTask = runTasks[0];
+    }
+  } catch (error) {
+    console.warn('Could not detect gradle tasks, using default "run":', error);
+  }
+
+  // Launch app via gradle
+  const process = spawn('./gradlew', [runTask, '--quiet'], {
+    cwd: projectPath,
+    stdio: 'inherit',
+  });
+
+  return { process };
+}
+
+async function stopIOSApp(device: Device, bundleId: string): Promise<void> {
+  try {
+    await execFileAsync('xcrun', ['simctl', 'terminate', device.id, bundleId]);
+  } catch (error) {
+    console.warn('Could not stop iOS app:', error);
+  }
+}
+
+async function stopAndroidApp(device: Device, bundleId: string, force: boolean): Promise<void> {
+  try {
+    const command = force ? 'force-stop' : 'stop';
+    await execFileAsync('adb', ['-s', device.id, 'shell', 'am', command, bundleId]);
+  } catch (error) {
+    console.warn(`Could not stop Android app (${force ? 'force' : 'graceful'}):`, error);
+  }
+}
+
+async function installApp(
+  projectPath: string,
+  platformType: PlatformType,
+  device: Device | null,
+  bundleInfo: BundleInfo
+): Promise<void> {
+  if (platformType === 'flutter' || platformType === 'kmp-android') {
+    if (device?.type === 'android') {
+      const gradleRoot = platformType === 'flutter' ? `${projectPath}/android` : projectPath;
+      await execFileAsync('./gradlew', ['installDebug'], {
+        cwd: gradleRoot,
+        timeout: 300000,
+      });
+    }
+    // iOS apps are installed automatically during development
+  } else if (platformType === 'expo') {
+    // Expo installation typically handled by expo-cli
+    throw new Error('Expo installation not yet supported');
+  }
+}
+
+async function uninstallApp(
+  platformType: PlatformType,
+  device: Device | null,
+  bundleInfo: BundleInfo
+): Promise<void> {
+  if (device?.type === 'android' && bundleInfo.android) {
+    try {
+      await execFileAsync('adb', ['-s', device.id, 'uninstall', bundleInfo.android]);
+    } catch (error) {
+      // App might not be installed, ignore error
+    }
+  } else if (device?.type === 'ios' && bundleInfo.ios) {
+    try {
+      await execFileAsync('xcrun', ['simctl', 'uninstall', device.id, bundleInfo.ios]);
+    } catch (error) {
+      // App might not be installed, ignore error
+    }
+  }
+}
+
+async function clearAppData(
+  platformType: PlatformType,
+  device: Device | null,
+  bundleInfo: BundleInfo
+): Promise<void> {
+  if (device?.type === 'android' && bundleInfo.android) {
+    try {
+      await execFileAsync('adb', ['-s', device.id, 'shell', 'pm', 'clear', bundleInfo.android]);
+    } catch (error) {
+      console.warn('Could not clear Android app data:', error);
+    }
+  } else if (device?.type === 'ios' && bundleInfo.ios) {
+    // iOS: uninstall and reinstall to clear data
+    await uninstallApp(platformType, device, bundleInfo);
+    console.warn('iOS data cleared by uninstalling app. Reinstall required.');
+  }
+}
+
+function capitalize(str: string): string {
+  return str.charAt(0).toUpperCase() + str.slice(1);
+}
diff --git a/packages/core/src/node/bundle-resolver.test.ts b/packages/core/src/node/bundle-resolver.test.ts
new file mode 100644
index 0000000..dea9b79
--- /dev/null
+++ b/packages/core/src/node/bundle-resolver.test.ts
@@ -0,0 +1,163 @@
+import { resolveBundleIds } from './bundle-resolver';
+import { existsSync, readFileSync } from 'fs';
+import { execSync } from 'child_process';
+
+jest.mock('fs');
+jest.mock('child_process');
+
+const mockExistsSync = existsSync as jest.MockedFunction<typeof existsSync>;
+const mockReadFileSync = readFileSync as jest.MockedFunction<typeof readFileSync>;
+const mockExecSync = execSync as jest.MockedFunction<typeof execSync>;
+
+describe('bundle-resolver', () => {
+  beforeEach(() => {
+    jest.clearAllMocks();
+  });
+
+  describe('resolveBundleIds', () => {
+    it('should resolve Flutter bundle IDs from gradle.kts', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        const pathStr = path.toString();
+        return pathStr.includes('build.gradle.kts') || pathStr.includes('project.pbxproj');
+      });
+      mockReadFileSync.mockImplementation((path: any) => {
+        if (path.toString().includes('android')) {
+          return 'applicationId = "com.example.flutter"';
+        }
+        if (path.toString().includes('project.pbxproj')) {
+          return 'PRODUCT_BUNDLE_IDENTIFIER = com.example.flutter.ios;';
+        }
+        return '';
+      });
+
+      const result = await resolveBundleIds('/test/flutter-app', 'flutter');
+
+      expect(result.android).toBe('com.example.flutter');
+      expect(result.ios).toBe('com.example.flutter.ios');
+      expect(result.androidMainActivity).toBe('com.example.flutter.MainActivity');
+    });
+
+    it('should resolve Flutter bundle IDs from build.gradle (groovy)', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        return path.toString().includes('build.gradle') && !path.toString().includes('.kts');
+      });
+      mockReadFileSync.mockImplementation((path: any) => {
+        if (path.toString().includes('android')) {
+          return 'applicationId "com.example.flutter"';
+        }
+        return '';
+      });
+
+      const result = await resolveBundleIds('/test/flutter-app', 'flutter');
+
+      expect(result.android).toBe('com.example.flutter');
+    });
+
+    it('should fallback to xcodebuild for iOS bundle ID', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        return path.toString().includes('ios');
+      });
+      mockReadFileSync.mockReturnValue('// no bundle ID here');
+      mockExecSync.mockReturnValue('    PRODUCT_BUNDLE_IDENTIFIER = com.fallback.ios\n');
+
+      const result = await resolveBundleIds('/test/flutter-app', 'flutter');
+
+      expect(result.ios).toBe('com.fallback.ios');
+    });
+
+    it('should resolve Expo bundle IDs from app.json', async () => {
+      mockExistsSync.mockReturnValue(true);
+      mockReadFileSync.mockReturnValue(
+        JSON.stringify({
+          expo: {
+            ios: { bundleIdentifier: 'com.example.expo.ios' },
+            android: { package: 'com.example.expo' },
+          },
+        })
+      );
+
+      const result = await resolveBundleIds('/test/expo-app', 'expo');
+
+      expect(result.ios).toBe('com.example.expo.ios');
+      expect(result.android).toBe('com.example.expo');
+      expect(result.androidMainActivity).toBe('com.example.expo.MainActivity');
+    });
+
+    it('should resolve KMP Android bundle ID', async () => {
+      mockExistsSync.mockReturnValue(true);
+      mockReadFileSync.mockReturnValue('applicationId = "io.agenteract.kmp"');
+
+      const result = await resolveBundleIds('/test/kmp-app', 'kmp-android');
+
+      expect(result.android).toBe('io.agenteract.kmp');
+      expect(result.androidMainActivity).toBe('io.agenteract.kmp.MainActivity');
+    });
+
+    it('should return empty for KMP Desktop (no bundle ID needed)', async () => {
+      const result = await resolveBundleIds('/test/kmp-app', 'kmp-desktop');
+
+      expect(result).toEqual({ androidMainActivity: undefined });
+    });
+
+    it('should return empty for Vite (web app)', async () => {
+      const result = await resolveBundleIds('/test/vite-app', 'vite');
+
+      expect(result).toEqual({ androidMainActivity: undefined });
+    });
+
+    it('should apply bundle ID overrides from config', async () => {
+      mockExistsSync.mockReturnValue(true);
+      mockReadFileSync.mockReturnValue('applicationId = "com.example.old"');
+
+      const result = await resolveBundleIds('/test/flutter-app', 'flutter', {
+        bundleId: {
+          ios: 'com.override.ios',
+          android: 'com.override.android',
+        },
+      });
+
+      expect(result.ios).toBe('com.override.ios');
+      expect(result.android).toBe('com.override.android');
+    });
+
+    it('should apply mainActivity override from config', async () => {
+      mockExistsSync.mockReturnValue(true);
+      mockReadFileSync.mockReturnValue('applicationId = "com.example.app"');
+
+      const result = await resolveBundleIds('/test/flutter-app', 'flutter', {
+        mainActivity: 'com.custom.CustomActivity',
+      });
+
+      expect(result.androidMainActivity).toBe('com.custom.CustomActivity');
+    });
+
+    it('should handle missing app.json gracefully', async () => {
+      mockExistsSync.mockReturnValue(false);
+
+      const result = await resolveBundleIds('/test/expo-app', 'expo');
+
+      expect(result).toEqual({ androidMainActivity: undefined });
+    });
+
+    it('should handle malformed JSON gracefully', async () => {
+      mockExistsSync.mockReturnValue(true);
+      mockReadFileSync.mockReturnValue('{ invalid json }');
+
+      const result = await resolveBundleIds('/test/expo-app', 'expo');
+
+      expect(result).toEqual({ androidMainActivity: undefined });
+    });
+
+    it('should handle xcodebuild command failure', async () => {
+      mockExistsSync.mockReturnValue(true);
+      mockReadFileSync.mockReturnValue('// no bundle ID');
+      mockExecSync.mockImplementation(() => {
+        throw new Error('xcodebuild not found');
+      });
+
+      const result = await resolveBundleIds('/test/flutter-app', 'flutter');
+
+      expect(result.ios).toBeUndefined();
+    });
+  });
+});
diff --git a/packages/core/src/node/bundle-resolver.ts b/packages/core/src/node/bundle-resolver.ts
new file mode 100644
index 0000000..0c8067f
--- /dev/null
+++ b/packages/core/src/node/bundle-resolver.ts
@@ -0,0 +1,172 @@
+import { existsSync, readFileSync, readdirSync } from 'fs';
+import { join } from 'path';
+import { execSync } from 'child_process';
+import { PlatformType } from './platform-detector';
+
+export interface BundleInfo {
+  ios?: string;
+  android?: string;
+  androidMainActivity?: string;
+}
+
+/**
+ * Extract bundle IDs for the given platform
+ */
+export async function resolveBundleIds(
+  projectPath: string,
+  platformType: PlatformType,
+  overrides?: { bundleId?: { ios?: string; android?: string }; mainActivity?: string }
+): Promise<BundleInfo> {
+  const result: BundleInfo = {};
+
+  switch (platformType) {
+    case 'flutter':
+      await resolveFlutterBundleIds(projectPath, result);
+      break;
+    case 'expo':
+      await resolveExpoBundleIds(projectPath, result);
+      break;
+    case 'kmp-android':
+      await resolveKmpAndroidBundleIds(projectPath, result);
+      break;
+    case 'kmp-desktop':
+      // Desktop doesn't need bundle IDs
+      break;
+    case 'swiftui':
+      await resolveSwiftUIBundleIds(projectPath, result);
+      break;
+    case 'vite':
+      // Web doesn't need bundle IDs
+      break;
+  }
+
+  // Apply overrides (they take precedence over detected values)
+  if (overrides?.bundleId?.ios) {
+    result.ios = overrides.bundleId.ios;
+  }
+  if (overrides?.bundleId?.android) {
+    result.android = overrides.bundleId.android;
+  }
+
+  // Generate MainActivity if we have an Android bundle ID
+  if (result.android && !result.androidMainActivity) {
+    result.androidMainActivity = overrides?.mainActivity || `${result.android}.MainActivity`;
+  }
+
+  return result;
+}
+
+async function resolveFlutterBundleIds(projectPath: string, result: BundleInfo) {
+  // Android: check both .kts and .gradle files
+  const androidBuildKts = join(projectPath, 'android/app/build.gradle.kts');
+  const androidBuildGradle = join(projectPath, 'android/app/build.gradle');
+
+  if (existsSync(androidBuildKts)) {
+    const content = readFileSync(androidBuildKts, 'utf-8');
+    const match = content.match(/applicationId\s*=\s*"([^"]+)"/);
+    if (match) {
+      result.android = match[1];
+    }
+  } else if (existsSync(androidBuildGradle)) {
+    const content = readFileSync(androidBuildGradle, 'utf-8');
+    const match = content.match(/applicationId\s+["']([^"']+)["']/);
+    if (match) {
+      result.android = match[1];
+    }
+  }
+
+  // iOS: try xcodeproj first, then fallback to xcodebuild
+  const xcodeProj = join(projectPath, 'ios/Runner.xcodeproj/project.pbxproj');
+  if (existsSync(xcodeProj)) {
+    const content = readFileSync(xcodeProj, 'utf-8');
+    const match = content.match(/PRODUCT_BUNDLE_IDENTIFIER\s*=\s*([^;]+);/);
+    if (match) {
+      result.ios = match[1].trim();
+    }
+  }
+
+  // Fallback to xcodebuild if no match
+  if (!result.ios && existsSync(join(projectPath, 'ios'))) {
+    try {
+      const output = execSync(
+        'xcodebuild -showBuildSettings | grep PRODUCT_BUNDLE_IDENTIFIER',
+        {
+          cwd: join(projectPath, 'ios'),
+          encoding: 'utf-8',
+          timeout: 10000,
+        }
+      );
+      const match = output.match(/PRODUCT_BUNDLE_IDENTIFIER\s*=\s*(.+)/);
+      if (match) {
+        result.ios = match[1].trim();
+      }
+    } catch (error) {
+      console.warn('Could not determine iOS bundle ID from xcodebuild:', error);
+    }
+  }
+}
+
+async function resolveExpoBundleIds(projectPath: string, result: BundleInfo) {
+  const appJsonPath = join(projectPath, 'app.json');
+  if (!existsSync(appJsonPath)) {
+    return;
+  }
+
+  try {
+    const appJson = JSON.parse(readFileSync(appJsonPath, 'utf-8'));
+    if (appJson.expo) {
+      result.ios = appJson.expo.ios?.bundleIdentifier;
+      result.android = appJson.expo.android?.package;
+    }
+  } catch (error) {
+    console.warn('Could not parse app.json:', error);
+  }
+}
+
+async function resolveKmpAndroidBundleIds(projectPath: string, result: BundleInfo) {
+  const composeAppBuild = join(projectPath, 'composeApp/build.gradle.kts');
+  if (existsSync(composeAppBuild)) {
+    const content = readFileSync(composeAppBuild, 'utf-8');
+    const match = content.match(/applicationId\s*=\s*"([^"]+)"/);
+    if (match) {
+      result.android = match[1];
+    }
+  }
+}
+
+async function resolveSwiftUIBundleIds(projectPath: string, result: BundleInfo) {
+  // Find xcodeproj
+  const files = readdirSync(projectPath);
+  const xcodeProject = files.find((f: string) => f.endsWith('.xcodeproj'));
+
+  if (xcodeProject) {
+    const pbxprojPath = join(projectPath, xcodeProject, 'project.pbxproj');
+    if (existsSync(pbxprojPath)) {
+      const content = readFileSync(pbxprojPath, 'utf-8');
+      const match = content.match(/PRODUCT_BUNDLE_IDENTIFIER\s*=\s*([^;]+);/);
+      if (match) {
+        result.ios = match[1].trim();
+      }
+    }
+  }
+
+  // Fallback to xcodebuild
+  if (!result.ios) {
+    try {
+      const output = execSync(
+        'xcodebuild -showBuildSettings | grep PRODUCT_BUNDLE_IDENTIFIER',
+        {
+          cwd: projectPath,
+          encoding: 'utf-8',
+          timeout: 10000,
+        }
+      );
+      const match = output.match(/PRODUCT_BUNDLE_IDENTIFIER\s*=\s*(.+)/);
+      if (match) {
+        result.ios = match[1].trim();
+      }
+    } catch (error) {
+      console.warn('Could not determine bundle ID from xcodebuild:', error);
+    }
+  }
+}
diff --git a/packages/core/src/node/device-manager.test.ts b/packages/core/src/node/device-manager.test.ts
new file mode 100644
index 0000000..8ff002c
--- /dev/null
+++ b/packages/core/src/node/device-manager.test.ts
@@ -0,0 +1,364 @@
+const mockExecFileAsync = jest.fn();
+
+jest.mock('child_process', () => ({
+  execFile: jest.fn(),
+}));
+
+jest.mock('util', () => ({
+  promisify: jest.fn(() => mockExecFileAsync),
+}));
+
+import { listIOSDevices, listAndroidDevices, selectDevice } from './device-manager';
+
+describe('device-manager', () => {
+  beforeEach(() => {
+    jest.clearAllMocks();
+  });
+
+  describe('listIOSDevices', () => {
+    it('should return empty array on non-macOS platforms', async () => {
+      const originalPlatform = process.platform;
+      Object.defineProperty(process, 'platform', { value: 'win32' });
+
+      const devices = await listIOSDevices();
+
+      expect(devices).toEqual([]);
+
+      Object.defineProperty(process, 'platform', { value: originalPlatform });
+    });
+
+    it('should return empty array if xcrun not available', async () => {
+      const originalPlatform = process.platform;
+      Object.defineProperty(process, 'platform', { value: 'darwin' });
+
+      mockExecFileAsync.mockImplementation(async (cmd: string) => {
+        if (cmd === 'which' || cmd === 'where') {
+          throw new Error('Command not found');
+        }
+        return { stdout: '', stderr: '' };
+      });
+
+      const devices = await listIOSDevices();
+
+      expect(devices).toEqual([]);
+
+      Object.defineProperty(process, 'platform', { value: originalPlatform });
+    });
+
+    it('should parse iOS simulator list correctly', async () => {
+      const originalPlatform = process.platform;
+      Object.defineProperty(process, 'platform', { value: 'darwin' });
+
+      mockExecFileAsync.mockImplementation(async (cmd: string, args?: any[]) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/xcrun', stderr: '' };
+        }
+        if (cmd === 'xcrun' && args?.[0] === 'simctl') {
+          return {
+            stdout: JSON.stringify({
+              devices: {
+                'com.apple.CoreSimulator.SimRuntime.iOS-17-0': [
+                  {
+                    udid: 'ABC-123',
+                    name: 'iPhone 15 Pro',
+                    state: 'Booted',
+                  },
+                  {
+                    udid: 'DEF-456',
+                    name: 'iPhone 15',
+                    state: 'Shutdown',
+                  },
+                ],
+              },
+            }),
+            stderr: '',
+          };
+        }
+        return { stdout: '', stderr: '' };
+      });
+
+      const devices = await listIOSDevices();
+
+      expect(devices).toHaveLength(2);
+      expect(devices[0]).toEqual({
+        id: 'ABC-123',
+        name: expect.stringContaining('iPhone 15 Pro'),
+        type: 'ios',
+        state: 'booted',
+      });
+      expect(devices[1]).toEqual({
+        id: 'DEF-456',
+        name: expect.stringContaining('iPhone 15'),
+        type: 'ios',
+        state: 'shutdown',
+      });
+
+      Object.defineProperty(process, 'platform', { value: originalPlatform });
+    });
+
+    it('should handle xcrun simctl errors gracefully', async () => {
+      const originalPlatform = process.platform;
+      Object.defineProperty(process, 'platform', { value: 'darwin' });
+
+      mockExecFileAsync.mockImplementation(async (cmd: string, args?: any[]) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/xcrun', stderr: '' };
+        }
+        throw new Error('simctl error');
+      });
+
+      const devices = await listIOSDevices();
+
+      expect(devices).toEqual([]);
+
+      Object.defineProperty(process, 'platform', { value: originalPlatform });
+    });
+  });
+
+  describe('listAndroidDevices', () => {
+    it('should return empty array if adb not available', async () => {
+      mockExecFileAsync.mockImplementation(async () => {
+        throw new Error('Command not found');
+      });
+
+      const devices = await listAndroidDevices();
+
+      expect(devices).toEqual([]);
+    });
+
+    it('should parse adb devices list correctly', async () => {
+      mockExecFileAsync.mockImplementation(async (cmd: string, args?: any[]) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/adb', stderr: '' };
+        }
+        if (cmd === 'adb' && args?.[0] === 'devices') {
+          return {
+            stdout: 'List of devices attached\nemulator-5554\tdevice\nemulator-5556\tdevice\n',
+            stderr: '',
+          };
+        }
+        if (cmd === 'adb' && args?.includes('getprop')) {
+          return {
+            stdout: args[1] === 'emulator-5554' ? 'Pixel 5' : 'Pixel 6',
+            stderr: '',
+          };
+        }
+        return { stdout: '', stderr: '' };
+      });
+
+      const devices = await listAndroidDevices();
+
+      expect(devices).toHaveLength(2);
+      expect(devices[0].id).toBe('emulator-5554');
+      expect(devices[0].type).toBe('android');
+      expect(devices[0].state).toBe('booted');
+    });
+
+    it('should handle device name fetch errors', async () => {
+      mockExecFileAsync.mockImplementation(async (cmd: string, args?: any[]) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/adb', stderr: '' };
+        }
+        if (cmd === 'adb' && args?.[0] === 'devices') {
+          return {
+            stdout: 'List of devices attached\nemulator-5554\tdevice\n',
+            stderr: '',
+          };
+        }
+        if (cmd === 'adb' && args?.includes('getprop')) {
+          throw new Error('getprop failed');
+        }
+        return { stdout: '', stderr: '' };
+      });
+
+      const devices = await listAndroidDevices();
+
+      expect(devices).toHaveLength(1);
+      expect(devices[0].id).toBe('emulator-5554');
+      expect(devices[0].name).toContain('emulator-5554');
+    });
+
+    it('should handle adb command errors gracefully', async () => {
+      mockExecFileAsync.mockImplementation(async (cmd: string) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/adb', stderr: '' };
+        }
+        throw new Error('adb error');
+      });
+
+      const devices = await listAndroidDevices();
+
+      expect(devices).toEqual([]);
+    });
+  });
+
+  describe('selectDevice', () => {
+    beforeEach(() => {
+      mockExecFileAsync.mockImplementation(async () => {
+        throw new Error('No devices');
+      });
+    });
+
+    it('should return desktop device for desktop platform', async () => {
+      const device = await selectDevice(undefined, 'desktop');
+
+      expect(device).toEqual({
+        id: 'desktop',
+        name: 'Desktop',
+        type: 'desktop',
+        state: 'available',
+      });
+    });
+
+    it('should return desktop device for desktop request', async () => {
+      const device = await selectDevice('desktop', undefined);
+
+      expect(device).toEqual({
+        id: 'desktop',
+        name: 'Desktop',
+        type: 'desktop',
+        state: 'available',
+      });
+    });
+
+    it('should return requested device if available', async () => {
+      const originalPlatform = process.platform;
+      Object.defineProperty(process, 'platform', { value: 'darwin' });
+
+      mockExecFileAsync.mockImplementation(async (cmd: string, args?: any[]) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/xcrun', stderr: '' };
+        }
+        if (cmd === 'xcrun') {
+          return {
+            stdout: JSON.stringify({
+              devices: {
+                'com.apple.CoreSimulator.SimRuntime.iOS-17-0': [
+                  {
+                    udid: 'REQUESTED-ID',
+                    name: 'iPhone 15',
+                    state: 'Shutdown',
+                  },
+                ],
+              },
+            }),
+            stderr: '',
+          };
+        }
+        return { stdout: '', stderr: '' };
+      });
+
+      const device = await selectDevice('REQUESTED-ID', 'ios');
+
+      expect(device?.id).toBe('REQUESTED-ID');
+
+      Object.defineProperty(process, 'platform', { value: originalPlatform });
+    });
+
+    it('should return first booted device if no specific device requested', async () => {
+      const originalPlatform = process.platform;
+      Object.defineProperty(process, 'platform', { value: 'darwin' });
+
+      mockExecFileAsync.mockImplementation(async (cmd: string, args?: any[]) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/xcrun', stderr: '' };
+        }
+        if (cmd === 'xcrun') {
+          return {
+            stdout: JSON.stringify({
+              devices: {
+                'com.apple.CoreSimulator.SimRuntime.iOS-17-0': [
+                  {
+                    udid: 'SHUTDOWN-ID',
+                    name: 'iPhone 14',
+                    state: 'Shutdown',
+                  },
+                  {
+                    udid: 'BOOTED-ID',
+                    name: 'iPhone 15',
+                    state: 'Booted',
+                  },
+                ],
+              },
+            }),
+            stderr: '',
+          };
+        }
+        return { stdout: '', stderr: '' };
+      });
+
+      const device = await selectDevice(undefined, 'ios');
+
+      expect(device?.id).toBe('BOOTED-ID');
+
+      Object.defineProperty(process, 'platform', { value: originalPlatform });
+    });
+
+    it('should return first available device if none booted', async () => {
+      const originalPlatform = process.platform;
+      Object.defineProperty(process, 'platform', { value: 'darwin' });
+
+      mockExecFileAsync.mockImplementation(async (cmd: string, args?: any[]) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/xcrun', stderr: '' };
+        }
+        if (cmd === 'xcrun') {
+          return {
+            stdout: JSON.stringify({
+              devices: {
+                'com.apple.CoreSimulator.SimRuntime.iOS-17-0': [
+                  {
+                    udid: 'FIRST-ID',
+                    name: 'iPhone 14',
+                    state: 'Shutdown',
+                  },
+                  {
+                    udid: 'SECOND-ID',
+                    name: 'iPhone 15',
+                    state: 'Shutdown',
+                  },
+                ],
+              },
+            }),
+            stderr: '',
+          };
+        }
+        return { stdout: '', stderr: '' };
+      });
+
+      const device = await selectDevice(undefined, 'ios');
+
+      expect(device?.id).toBe('FIRST-ID');
+
+      Object.defineProperty(process, 'platform', { value: originalPlatform });
+    });
+
+    it('should return null if no devices available', async () => {
+      const device = await selectDevice(undefined, 'ios');
+
+      expect(device).toBeNull();
+    });
+
+    it('should check both iOS and Android if no platform specified', async () => {
+      mockExecFileAsync.mockImplementation(async (cmd: string, args?: any[]) => {
+        if (cmd === 'which' || cmd === 'where') {
+          return { stdout: '/usr/bin/adb', stderr: '' };
+        }
+        if (cmd === 'adb' && args?.[0] === 'devices') {
+          return {
+            stdout: 'List of devices attached\nemulator-5554\tdevice\n',
+            stderr: '',
+          };
+        }
+        if (cmd === 'adb' && args?.includes('getprop')) {
+          return { stdout: 'Pixel 5', stderr: '' };
+        }
+        return { stdout: '', stderr: '' };
+      });
+
+      const device = await selectDevice(undefined, undefined);
+
+      expect(device?.type).toBe('android');
+    });
+  });
+});
diff --git a/packages/core/src/node/device-manager.ts b/packages/core/src/node/device-manager.ts
new file mode 100644
index 0000000..f047004
--- /dev/null
+++ b/packages/core/src/node/device-manager.ts
@@ -0,0 +1,177 @@
+import { execFile } from 'child_process';
+import { promisify } from 'util';
+
+const execFileAsync = promisify(execFile);
+
+export interface Device {
+  id: string;
+  name: string;
+  type: 'ios' | 'android' | 'desktop' | 'web';
+  state?: 'booted' | 'shutdown' | 'available';
+}
+
+async function checkCommandExists(command: string): Promise<boolean> {
+  try {
+    await execFileAsync(process.platform === 'win32' ? 'where' : 'which', [command]);
+    return true;
+  } catch {
+    return false;
+  }
+}
+
+/**
+ * List available iOS simulators
+ */
+export async function listIOSDevices(): Promise<Device[]> {
+  if (process.platform !== 'darwin') {
+    return [];
+  }
+
+  const hasXcrun = await checkCommandExists('xcrun');
+  if (!hasXcrun) {
+    return [];
+  }
+
+  try {
+    const { stdout } = await execFileAsync('xcrun', ['simctl', 'list', 'devices', 'available', '--json']);
+    const data = JSON.parse(stdout);
+    const devices: Device[] = [];
+
+    for (const runtime of Object.keys(data.devices)) {
+      for (const device of data.devices[runtime]) {
+        devices.push({
+          id: device.udid,
+          name: `${device.name} (${runtime.replace('com.apple.CoreSimulator.SimRuntime.', '').replace(/-/g, ' ')})`,
+          type: 'ios',
+          state: device.state === 'Booted' ? 'booted' : 'shutdown',
+        });
+      }
+    }
+
+    return devices;
+  } catch (error) {
+    console.warn('Could not list iOS devices:', (error as Error).message);
+    return [];
+  }
+}
+
+/**
+ * List available Android devices/emulators
+ */
+export async function listAndroidDevices(): Promise<Device[]> {
+  const hasAdb = await checkCommandExists('adb');
+  if (!hasAdb) {
+    return [];
+  }
+
+  try {
+    const { stdout } = await execFileAsync('adb', ['devices']);
+    const lines = stdout.split('\n').slice(1); // Skip header
+    const devices: Device[] = [];
+
+    for (const line of lines) {
+      const match = line.match(/^(\S+)\s+device$/);
+      if (match) {
+        const id = match[1];
+        // Get device name
+        try {
+          const { stdout: nameStdout } = await execFileAsync('adb', [
+            '-s',
+            id,
+            'shell',
+            'getprop',
+            'ro.product.model',
+          ]);
+          const name = nameStdout.trim() || id;
+          devices.push({
+            id,
+            name: `${name} (Android)`,
+            type: 'android',
+            state: 'booted',
+          });
+        } catch {
+          devices.push({
+            id,
+            name: `${id} (Android)`,
+            type: 'android',
+            state: 'booted',
+          });
+        }
+      }
+    }
+
+    return devices;
+  } catch (error) {
+    console.warn('Could not list Android devices:', (error as Error).message);
+    return [];
+  }
+}
+
+/**
+ * Select a device based on the selection criteria
+ * 1. Try requested device ID
+ * 2. Try first booted device
+ * 3. Try first available device
+ * 4. Return null if none found
+ */
+export async function selectDevice(
+  requestedDeviceId: string | undefined,
+  platform: 'ios' | 'android' | 'desktop' | 'web' | undefined
+): Promise<Device | null> {
+  // Special case for desktop/web platform
+  if (platform === 'desktop' || requestedDeviceId === 'desktop') {
+    return {
+      id: 'desktop',
+      name: 'Desktop',
+      type: 'desktop',
+      state: 'available',
+    };
+  }
+
+  if (platform === 'web' || requestedDeviceId === 'web') {
+    return {
+      id: 'web',
+      name: 'Web Browser',
+      type: 'web',
+      state: 'available',
+    };
+  }
+
+  // Determine which platforms to check
+  const checkIOS = !platform || platform === 'ios';
+  const checkAndroid = !platform || platform === 'android';
+
+  let allDevices: Device[] = [];
+
+  if (checkIOS) {
+    const iosDevices = await listIOSDevices();
+    allDevices = allDevices.concat(iosDevices);
+  }
+
+  if (checkAndroid) {
+    const androidDevices = await listAndroidDevices();
+    allDevices = allDevices.concat(androidDevices);
+  }
+
+  // 1. Try requested device ID
+  if (requestedDeviceId) {
+    const requested = allDevices.find((d) => d.id === requestedDeviceId);
+    if (requested) {
+      return requested;
+    }
+  }
+
+  // 2. Try first booted device
+  const booted = allDevices.find((d) => d.state === 'booted');
+  if (booted) {
+    return booted;
+  }
+
+  // 3. Try first available device
+  if (allDevices.length > 0) {
+    return allDevices[0];
+  }
+
+  // 4. No device found
+  return null;
+}
diff --git a/packages/core/src/node/index.ts b/packages/core/src/node/index.ts
index d853e1c..1757481 100644
--- a/packages/core/src/node/index.ts
+++ b/packages/core/src/node/index.ts
@@ -1,2 +1,6 @@
 export * from './config.js';
 export * from './pnpm.js';
+export * from './platform-detector.js';
+export * from './bundle-resolver.js';
+export * from './device-manager.js';
+export * from './app-launcher.js';
diff --git a/packages/core/src/node/platform-detector.test.ts b/packages/core/src/node/platform-detector.test.ts
new file mode 100644
index 0000000..627f9de
--- /dev/null
+++ b/packages/core/src/node/platform-detector.test.ts
@@ -0,0 +1,125 @@
+import { detectPlatform } from './platform-detector';
+import { existsSync, readFileSync, readdirSync } from 'fs';
+import { execSync } from 'child_process';
+
+jest.mock('fs');
+jest.mock('child_process');
+
+const mockExistsSync = existsSync as jest.MockedFunction<typeof existsSync>;
+const mockReadFileSync = readFileSync as jest.MockedFunction<typeof readFileSync>;
+const mockReaddirSync = readdirSync as jest.MockedFunction<typeof readdirSync>;
+const mockExecSync = execSync as jest.MockedFunction<typeof execSync>;
+
+describe('platform-detector', () => {
+  beforeEach(() => {
+    jest.clearAllMocks();
+  });
+
+  describe('detectPlatform', () => {
+    it('should detect Flutter platform when pubspec.yaml exists', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        return path.toString().includes('pubspec.yaml');
+      });
+
+      const result = await detectPlatform('/test/flutter-project');
+
+      expect(result.type).toBe('flutter');
+      expect(result.projectRoot).toBe('/test/flutter-project');
+      expect(result.bundleIdFiles).toContain('ios/Runner.xcodeproj/project.pbxproj');
+      expect(result.bundleIdFiles).toContain('android/app/build.gradle.kts');
+    });
+
+    it('should detect Expo platform when app.json with expo key exists', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        return path.toString().includes('app.json');
+      });
+      mockReadFileSync.mockReturnValue(JSON.stringify({ expo: { name: 'test' } }));
+
+      const result = await detectPlatform('/test/expo-project');
+
+      expect(result.type).toBe('expo');
+      expect(result.bundleIdFiles).toContain('app.json');
+    });
+
+    it('should detect KMP Android platform', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        return path.toString().includes('build.gradle.kts') ||
+               path.toString().includes('composeApp/build.gradle.kts');
+      });
+      mockReadFileSync.mockReturnValue('kotlin("multiplatform")\nandroid()');
+      mockExecSync.mockReturnValue('installDebug - Install debug build\nrunDebug - Run debug build');
+
+      const result = await detectPlatform('/test/kmp-project');
+
+      expect(result.type).toBe('kmp-android');
+      expect(result.gradleTasks).toContain('installDebug');
+      expect(result.gradleTasks).toContain('runDebug');
+    });
+
+    it('should detect KMP Desktop platform when only jvm target exists', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        return path.toString().includes('build.gradle.kts') ||
+               path.toString().includes('composeApp/build.gradle.kts');
+      });
+      mockReadFileSync.mockReturnValue('kotlin("multiplatform")\njvm()\ndesktop');
+      mockExecSync.mockReturnValue('desktopRun - Run desktop app');
+
+      const result = await detectPlatform('/test/kmp-desktop');
+
+      expect(result.type).toBe('kmp-desktop');
+      expect(result.gradleTasks).toContain('desktopRun');
+    });
+
+    it('should detect SwiftUI platform', async () => {
+      mockExistsSync.mockReturnValue(false);
+      mockReaddirSync.mockReturnValue(['MyApp.xcodeproj', 'Sources'] as any);
+
+      const result = await detectPlatform('/test/swiftui-project');
+
+      expect(result.type).toBe('swiftui');
+      expect(result.bundleIdFiles[0]).toContain('MyApp.xcodeproj/project.pbxproj');
+    });
+
+    it('should detect Vite platform', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        return path.toString().includes('vite.config.ts');
+      });
+      mockReaddirSync.mockReturnValue([] as any);
+
+      const result = await detectPlatform('/test/vite-project');
+
+      expect(result.type).toBe('vite');
+      expect(result.buildFiles).toContain('vite.config.ts');
+    });
+
+    it('should throw error if no platform detected', async () => {
+      mockExistsSync.mockReturnValue(false);
+      mockReaddirSync.mockReturnValue([] as any);
+
+      await expect(detectPlatform('/test/unknown')).rejects.toThrow(
+        'Could not detect platform type'
+      );
+    });
+
+    it('should handle gradle task detection errors gracefully', async () => {
+      mockExistsSync.mockImplementation((path: any) => {
+        return path.toString().includes('build.gradle.kts');
+      });
+      mockReadFileSync.mockReturnValue('kotlin("multiplatform")\nandroid()');
+      mockExecSync.mockImplementation(() => {
+        throw new Error('Gradle not found');
+      });
+
+      const result = await detectPlatform('/test/kmp-project');
+
+      expect(result.type).toBe('kmp-android');
+      expect(result.gradleTasks).toEqual([]);
+    });
+
+    it('should not throw if projectPath is missing', async () => {
+      await expect(detectPlatform('')).rejects.toThrow(
+        'Project path is required for platform detection'
+      );
+    });
+  });
+});
diff --git a/packages/core/src/node/platform-detector.ts b/packages/core/src/node/platform-detector.ts
new file mode 100644
index 0000000..f22a243
--- /dev/null
+++ b/packages/core/src/node/platform-detector.ts
@@ -0,0 +1,151 @@
+import { existsSync, readFileSync, readdirSync } from 'fs';
+import { join } from 'path';
+import { execSync } from 'child_process';
+
+export type PlatformType =
+  | 'flutter'
+  | 'expo'
+  | 'kmp-android'
+  | 'kmp-desktop'
+  | 'swiftui'
+  | 'vite';
+
+export interface PlatformInfo {
+  type: PlatformType;
+  projectRoot: string;
+  bundleIdFiles: string[];
+  buildFiles: string[];
+  gradleTasks?: string[];
+}
+
+/**
+ * Auto-detect project platform from file structure
+ */
+export async function detectPlatform(projectPath: string): Promise<PlatformInfo> {
+  if (!projectPath) {
+    throw new Error('Project path is required for platform detection');
+  }
+
+  // Flutter: pubspec.yaml exists
+  if (existsSync(join(projectPath, 'pubspec.yaml'))) {
+    return {
+      type: 'flutter',
+      projectRoot: projectPath,
+      bundleIdFiles: [
+        'ios/Runner.xcodeproj/project.pbxproj',
+        'android/app/build.gradle.kts',
+        'android/app/build.gradle',
+      ],
+      buildFiles: ['android/app/build.gradle.kts', 'android/app/build.gradle'],
+    };
+  }
+
+  // Expo: app.json with expo key
+  const appJsonPath = join(projectPath, 'app.json');
+  if (existsSync(appJsonPath)) {
+    try {
+      const appJson = JSON.parse(readFileSync(appJsonPath, 'utf-8'));
+      if (appJson.expo) {
+        return {
+          type: 'expo',
+          projectRoot: projectPath,
+          bundleIdFiles: ['app.json'],
+          buildFiles: ['app.json'],
+        };
+      }
+    } catch (error) {
+      // Not valid JSON or doesn't have expo key, continue detection
+    }
+  }
+
+  // KMP: build.gradle.kts with kotlin multiplatform plugin
+  const kmpBuildFile = join(projectPath, 'build.gradle.kts');
+  const composeAppBuildFile = join(projectPath, 'composeApp/build.gradle.kts');
+
+  if (existsSync(kmpBuildFile) || existsSync(composeAppBuildFile)) {
+    try {
+      // Check for kotlin multiplatform plugin
+      const buildContent = existsSync(kmpBuildFile)
+        ? readFileSync(kmpBuildFile, 'utf-8')
+        : '';
+      const composeContent = existsSync(composeAppBuildFile)
+        ? readFileSync(composeAppBuildFile, 'utf-8')
+        : '';
+
+      const isKmp = buildContent.includes('kotlin("multiplatform")') ||
+                    composeContent.includes('kotlin("multiplatform")');
+
+      if (isKmp) {
+        // Detect gradle tasks
+        let gradleTasks: string[] = [];
+        try {
+          const tasksOutput = execSync('./gradlew tasks --console=plain', {
+            cwd: projectPath,
+            encoding: 'utf-8',
+            timeout: 30000,
+          });
+
+          // Parse task names from output  
+          const taskLines = tasksOutput.split('\n');
+          gradleTasks = taskLines
+            .filter(line => line.includes('run') || line.includes('Run') || line.includes('install'))
+            .map(line => line.split(' ')[0].trim())
+            .filter(task => task.length > 0);
+        } catch (error) {
+          console.warn('Could not detect gradle tasks:', error);
+        }
+
+        // Determine if android or desktop based on targets
+        const hasAndroid = buildContent.includes('android()') || composeContent.includes('android()');
+        const hasDesktop = buildContent.includes('jvm()') ||
+                          composeContent.includes('jvm()') ||
+                          buildContent.includes('desktop') ||
+                          composeContent.includes('desktop');
+
+        // Default to android if both or neither detected
+        const type: PlatformType = hasDesktop && !hasAndroid ? 'kmp-desktop' : 'kmp-android';
+
+        return {
+          type,
+          projectRoot: projectPath,
+          bundleIdFiles: type === 'kmp-android' ? ['composeApp/build.gradle.kts'] : [],
+          buildFiles: ['composeApp/build.gradle.kts', 'build.gradle.kts'],
+          gradleTasks,
+        };
+      }
+    } catch (error) {
+      console.warn('Error checking KMP configuration:', error);
+    }
+  }
+
+  // SwiftUI: *.xcodeproj or *.xcworkspace exists
+  try {
+    const files = readdirSync(projectPath);
+    const hasXcodeProj = files.some((f: string) => f.endsWith('.xcodeproj') || f.endsWith('.xcworkspace'));
+
+    if (hasXcodeProj) {
+      const xcodeProject = files.find((f: string) => f.endsWith('.xcodeproj'));
+      return {
+        type: 'swiftui',
+        projectRoot: projectPath,
+        bundleIdFiles: [join(xcodeProject!, 'project.pbxproj')],
+        buildFiles: [join(xcodeProject!, 'project.pbxproj')],
+      };
+    }
+  } catch (error) {
+    // Continue detection
+  }
+
+  // Vite: vite.config.ts/js exists
+  if (existsSync(join(projectPath, 'vite.config.ts')) ||
+      existsSync(join(projectPath, 'vite.config.js'))) {
+    return {
+      type: 'vite',
+      projectRoot: projectPath,
+      bundleIdFiles: [],
+      buildFiles: ['vite.config.ts', 'vite.config.js'],
+    };
+  }
+
+  throw new Error(`Could not detect platform type for project at ${projectPath}`);
+}
diff --git a/packages/core/tsconfig.json b/packages/core/tsconfig.json
index 2d6b1f6..d929521 100644
--- a/packages/core/tsconfig.json
+++ b/packages/core/tsconfig.json
@@ -1,6 +1,6 @@
 {
   "extends": "../../tsconfig.base.json",
-  "exclude": ["node_modules", "dist"],
+  "exclude": ["node_modules", "dist", "**/*.test.ts"],
   "include": ["src"],
   "compilerOptions": {
     "outDir": "dist",
diff --git a/packages/flutter/lib/src/agent_debug_bridge.dart b/packages/flutter/lib/src/agent_debug_bridge.dart
index bf5b671..58061bb 100644
--- a/packages/flutter/lib/src/agent_debug_bridge.dart
+++ b/packages/flutter/lib/src/agent_debug_bridge.dart
@@ -26,6 +26,7 @@ class AgentDebugBridge extends StatefulWidget {
   final Widget child;
   final String? serverUrl;
   final bool autoConnect;
+  final Future<bool> Function(String url)? onAgentLink;
 
   const AgentDebugBridge({
     super.key,
@@ -33,6 +34,7 @@ class AgentDebugBridge extends StatefulWidget {
     required this.child,
     this.serverUrl,
     this.autoConnect = true,
+    this.onAgentLink,
   });
 
   @override
@@ -55,6 +57,12 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
   bool _shouldConnect = false;
   bool _configLoaded = false;
 
+  // Initialize console logger in constructor to capture early debugPrint calls
+  _AgentDebugBridgeState() {
+    // Access singleton to trigger initialization
+    ConsoleLogger.instance;
+  }
+
   String? get _serverUrl {
     if (widget.serverUrl != null) return widget.serverUrl;
 
@@ -85,6 +93,8 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
   @override
   void initState() {
     super.initState();
+    // Initialize console logger early to capture all debugPrint calls
+    ConsoleLogger.instance; // Access singleton to trigger initialization
     _init();
   }
 
@@ -110,17 +120,21 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
         if (host != null && port != null) {
           // Have saved config - connect
           _shouldConnect = true;
-          debugPrint('[Agenteract] Using saved config: ${_sanitizeConfigForLog(host, port, token, deviceId)}');
+          debugPrint(
+              '[Agenteract] Using saved config: ${_sanitizeConfigForLog(host, port, token, deviceId)}');
         } else {
           // No saved config - only connect if autoConnect is enabled and we have a default URL
           final hasDefaultUrl = _serverUrl != null;
           _shouldConnect = widget.autoConnect && hasDefaultUrl;
 
           if (hasDefaultUrl && _shouldConnect) {
-            debugPrint('[Agenteract] Will try connecting to default URL: $_serverUrl');
-            debugPrint('[Agenteract] On physical devices, this may fail. Use "agenteract connect" to pair.');
+            debugPrint(
+                '[Agenteract] Will try connecting to default URL: $_serverUrl');
+            debugPrint(
+                '[Agenteract] On physical devices, this may fail. Use "agenteract connect" to pair.');
           } else if (!hasDefaultUrl) {
-            debugPrint('[Agenteract] No default URL. Use "agenteract connect" to pair.');
+            debugPrint(
+                '[Agenteract] No default URL. Use "agenteract connect" to pair.');
           }
         }
       });
@@ -137,11 +151,11 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
       _connect();
     }
 
-    // 3. Listen for Deep Links
-    _initDeepLinks();
+    // 3. Listen for Agent Links (set up listener concurrently)
+    _initAgentLinks();
   }
 
-  Future<void> _initDeepLinks() async {
+  Future<void> _initAgentLinks() async {
     _appLinks = AppLinks();
 
     try {
@@ -157,6 +171,7 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
     }
 
     _linkSub = _appLinks.uriLinkStream.listen((Uri? uri) {
+      debugPrint('[Agenteract] uriLinkStream received: $uri');
       if (uri != null) _handleLink(uri.toString());
     }, onError: (err) {
       debugPrint('AgentDebugBridge: Error in link stream: $err');
@@ -164,20 +179,36 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
   }
 
   void _handleLink(String link) async {
+    debugPrint('[Agenteract] _handleLink called with: $link');
     try {
+      // Call custom agent link handler first if provided
+      if (widget.onAgentLink != null) {
+        debugPrint('[Agenteract] Calling custom onAgentLink handler');
+        final handled = await widget.onAgentLink!(link);
+        if (handled) {
+          debugPrint('[Agenteract] Deep link handled by app: $link');
+          return;
+        }
+      }
+
       final uri = Uri.parse(link);
+      debugPrint('[Agenteract] Parsed URI: host=${uri.host}, path=${uri.path}');
       // Expecting: scheme://agenteract/config?host=...&port=...&token=...
       // The host might be 'agenteract' or the scheme itself depending on config.
       // We check path segments.
-      
-      if (uri.path.contains('config') || uri.host == 'config' || uri.pathSegments.contains('config')) {
+
+      if (uri.path.contains('config') ||
+          uri.host == 'config' ||
+          uri.pathSegments.contains('config')) {
+        debugPrint('[Agenteract] Link identified as config link');
         final host = uri.queryParameters['host'];
         final portStr = uri.queryParameters['port'];
         final token = uri.queryParameters['token'];
 
         if (host != null && portStr != null && token != null) {
           final port = int.parse(portStr);
-          debugPrint('[Agenteract] Received config via Deep Link: ${_sanitizeConfigForLog(host, port, token, null)}');
+          debugPrint(
+              '[Agenteract] Received config via Deep Link: ${_sanitizeConfigForLog(host, port, token, null)}');
 
           final prefs = await SharedPreferences.getInstance();
           await prefs.setString('agenteract_host', host);
@@ -209,7 +240,7 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
     _disconnect();
     super.dispose();
   }
-  
+
   void _disconnect() {
     _channel?.sink.close();
     _channel = null;
@@ -220,13 +251,15 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
   void _connect() {
     if (_isConnecting) return;
     if (!_shouldConnect) {
-      debugPrint('[Agenteract] Auto-connect disabled. Use deep link to configure.');
+      debugPrint(
+          '[Agenteract] Auto-connect disabled. Use deep link to configure.');
       return;
     }
 
     final serverUrl = _serverUrl;
     if (serverUrl == null) {
-      debugPrint('[Agenteract] No server URL configured. Waiting for deep link...');
+      debugPrint(
+          '[Agenteract] No server URL configured. Waiting for deep link...');
       return;
     }
 
@@ -247,7 +280,8 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
       }
 
       final uri = Uri.parse(url);
-      debugPrint('[Agenteract] Connecting to ${uri.toString().replaceAll(RegExp(r'token=([^&]+)'), 'token=***')}');
+      debugPrint(
+          '[Agenteract] Connecting to ${uri.toString().replaceAll(RegExp(r'token=([^&]+)'), 'token=***')}');
 
       _channel = WebSocketChannel.connect(uri);
 
@@ -292,6 +326,7 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
 
   void _handleMessage(dynamic message) {
     try {
+      debugPrint('[Agenteract] Received WebSocket message');
       // Send device info on first message (connection is confirmed)
       if (!_deviceInfoSent) {
         _deviceInfoSent = true;
@@ -304,6 +339,10 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
       final action = data['action'] as String?;
       final id = data['id'] as String?;
 
+      if (action != null) {
+        debugPrint('[Agenteract] Handling action: $action');
+      }
+
       // Handle server-assigned device ID
       if (status == 'connected' && data['deviceId'] != null) {
         final deviceId = data['deviceId'] as String;
@@ -361,6 +400,9 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
             id,
           );
           break;
+        case 'agentLink':
+          _handleAgentLink(data['payload'] as String?, id);
+          break;
         default:
           _sendError('Unknown action: $action', id);
       }
@@ -472,6 +514,26 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
     }
   }
 
+  void _handleAgentLink(String? payload, String? id) async {
+    if (payload == null) {
+      _sendError('Missing payload', id);
+      return;
+    }
+
+    try {
+      if (widget.onAgentLink != null) {
+        final handled = await widget.onAgentLink!(payload);
+        if (handled) {
+          _sendSuccess(id);
+          return;
+        }
+      }
+      _sendError('No onAgentLink handler provided or link not handled', id);
+    } catch (e) {
+      _sendError('agentLink handler error: $e', id);
+    }
+  }
+
   void _sendSuccess(String? id) {
     _sendResponse({'status': 'ok', 'id': id});
   }
@@ -505,12 +567,17 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
         // Android emulator detection - check if running on x86/x64 (emulators) or look for emulator indicators
         final version = Platform.version;
         isSimulator = version.contains('(') &&
-                     (version.toLowerCase().contains('emulator') ||
-                      version.toLowerCase().contains('generic') ||
-                      Platform.environment['ANDROID_PRODUCT_MODEL']?.toLowerCase().contains('sdk') == true);
-
-        deviceModel = Platform.environment['ANDROID_PRODUCT_MODEL'] ?? 'Android Device';
-        deviceName = Platform.environment['ANDROID_PRODUCT_MANUFACTURER'] != null
+            (version.toLowerCase().contains('emulator') ||
+                version.toLowerCase().contains('generic') ||
+                Platform.environment['ANDROID_PRODUCT_MODEL']
+                        ?.toLowerCase()
+                        .contains('sdk') ==
+                    true);
+
+        deviceModel =
+            Platform.environment['ANDROID_PRODUCT_MODEL'] ?? 'Android Device';
+        deviceName = Platform.environment['ANDROID_PRODUCT_MANUFACTURER'] !=
+                null
             ? '${Platform.environment['ANDROID_PRODUCT_MANUFACTURER']} $deviceModel'
             : deviceModel;
 
@@ -518,8 +585,10 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
         // Example: "3.5.4 (stable) (Tue Oct 15 08:33:00 2024 +0000) on "android_x64""
         final match = RegExp(r'on "android[_\w]*"').firstMatch(version);
         if (match != null) {
-          final platformStr = match.group(0)?.replaceAll('on "', '').replaceAll('"', '') ?? '';
-          osVersion = 'Android ${platformStr.contains('_') ? platformStr.split('_').last : ''}';
+          final platformStr =
+              match.group(0)?.replaceAll('on "', '').replaceAll('"', '') ?? '';
+          osVersion =
+              'Android ${platformStr.contains('_') ? platformStr.split('_').last : ''}';
         } else {
           osVersion = 'Android';
         }
@@ -566,7 +635,8 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
     }
   }
 
-  String _sanitizeConfigForLog(String host, int port, String? token, String? deviceId) {
+  String _sanitizeConfigForLog(
+      String host, int port, String? token, String? deviceId) {
     var result = 'host: $host, port: $port';
     if (token != null) {
       result += ', token: ****';
@@ -581,4 +651,4 @@ class _AgentDebugBridgeState extends State<AgentDebugBridge> {
   Widget build(BuildContext context) {
     return widget.child;
   }
-}
\ No newline at end of file
+}
diff --git a/packages/flutter/lib/src/console_logger.dart b/packages/flutter/lib/src/console_logger.dart
index b64c608..349a755 100644
--- a/packages/flutter/lib/src/console_logger.dart
+++ b/packages/flutter/lib/src/console_logger.dart
@@ -1,3 +1,4 @@
+import 'dart:async';
 import 'package:flutter/foundation.dart';
 
 /// Log entry for console capture
@@ -47,8 +48,24 @@ class ConsoleLogger {
         _addLog('log', message);
       }
       // Call original debugPrint
-      _originalDebugPrint?.call(message, wrapWidth: wrapWidth);
+      if (_originalDebugPrint != null) {
+        _originalDebugPrint!(message, wrapWidth: wrapWidth);
+      } else {
+        // Fallback to standard print if debugPrint was null or became null
+        print(message);
+      }
     };
+
+    // Use Zone to capture all print calls as well
+    runZoned(
+      () {},
+      zoneSpecification: ZoneSpecification(
+        print: (Zone self, ZoneDelegate parent, Zone zone, String line) {
+          _addLog('log', line);
+          parent.print(zone, line);
+        },
+      ),
+    );
   }
 
   void _addLog(String level, String message) {
diff --git a/packages/flutter/lib/src/hierarchy_builder.dart b/packages/flutter/lib/src/hierarchy_builder.dart
index 03a8eb9..98e753d 100644
--- a/packages/flutter/lib/src/hierarchy_builder.dart
+++ b/packages/flutter/lib/src/hierarchy_builder.dart
@@ -14,7 +14,7 @@ Map<String, dynamic> _buildElementHierarchy(Element element) {
 
   // Check if this element has a registered test ID
   String? testID;
-  if (widget.key is ValueKey) {
+  if (widget.key != null) {
     // Check if this key is in our registry
     for (final id in getAllTestIDs()) {
       final agentNode = getAgentNode(id);
diff --git a/packages/kotlin/src/androidMain/kotlin/io/agenteract/DeepLinkHandler.kt b/packages/kotlin/src/androidMain/kotlin/io/agenteract/DeepLinkHandler.kt
index ab834ac..3597e5e 100644
--- a/packages/kotlin/src/androidMain/kotlin/io/agenteract/DeepLinkHandler.kt
+++ b/packages/kotlin/src/androidMain/kotlin/io/agenteract/DeepLinkHandler.kt
@@ -9,6 +9,12 @@ import android.net.Uri
  * Expected format: scheme://agenteract/config?host=...&port=...&token=...
  */
 object DeepLinkHandler {
+    /**
+     * Custom deep link handler callback
+     * Return true if the deep link was handled, false to let DeepLinkHandler process it
+     */
+    var customHandler: ((Uri) -> Boolean)? = null
+
     /**
      * Parse an Intent for Agenteract configuration deep link
      *
@@ -21,6 +27,16 @@ object DeepLinkHandler {
         }
 
         val uri = intent.data ?: return null
+        
+        // Call custom handler first if provided
+        if (customHandler != null) {
+            val handled = customHandler?.invoke(uri) ?: false
+            if (handled) {
+                println("[Agenteract] Deep link handled by app: $uri")
+                return null
+            }
+        }
+        
         return parseUri(uri)
     }
 
diff --git a/packages/kotlin/src/commonMain/kotlin/io/agenteract/AgentDebugBridge.kt b/packages/kotlin/src/commonMain/kotlin/io/agenteract/AgentDebugBridge.kt
index 2d40e76..7e88ec7 100644
--- a/packages/kotlin/src/commonMain/kotlin/io/agenteract/AgentDebugBridge.kt
+++ b/packages/kotlin/src/commonMain/kotlin/io/agenteract/AgentDebugBridge.kt
@@ -22,7 +22,8 @@ fun AgentDebugBridge(
     host: String = "localhost",
     port: Int = 8765,
     token: String? = null,
-    onConfigUpdate: ((AgenteractConfig) -> Unit)? = null
+    onConfigUpdate: ((AgenteractConfig) -> Unit)? = null,
+    onAgentLink: ((String) -> Unit)? = null
 ) {
     val scope = rememberCoroutineScope()
 
@@ -113,7 +114,7 @@ fun AgentDebugBridge(
 
                                 // Otherwise handle as command
                                 val command = json.decodeFromString<AgentCommand>(text)
-                                handleCommand(command, json) { cmdResponse ->
+                                handleCommand(command, json, onAgentLink) { cmdResponse ->
                                     val responseText = json.encodeToString(cmdResponse)
                                     send(responseText)
                                 }
@@ -161,11 +162,31 @@ private suspend fun sendDeviceInfo(
 private suspend fun handleCommand(
     command: AgentCommand,
     json: Json,
+    onAgentLink: ((String) -> Unit)? = null,
     sendResponse: suspend (AgentResponse) -> Unit
 ) {
     AgentLogger.log("Received command: ${command.action} id=${command.id}")
     
     when (command.action) {
+        "agentLink" -> {
+            val payload = command.payload
+            if (payload == null) {
+                sendResponse(AgentResponse(id = command.id, status = "error", error = "Missing payload"))
+                return
+            }
+            if (onAgentLink != null) {
+                // Call onAgentLink on main thread if possible, but here we are in suspend
+                // The handler should handle thread safety/dispatching if needed
+                try {
+                    onAgentLink(payload)
+                    sendResponse(AgentResponse(id = command.id, status = "ok"))
+                } catch (e: Exception) {
+                    sendResponse(AgentResponse(id = command.id, status = "error", error = "Agent link handler failed: $e"))
+                }
+            } else {
+                sendResponse(AgentResponse(id = command.id, status = "error", error = "No agent link handler registered"))
+            }
+        }
         "getViewHierarchy" -> {
             val hierarchy = AgentRegistry.getHierarchy()
             sendResponse(AgentResponse(
diff --git a/packages/kotlin/src/commonMain/kotlin/io/agenteract/AgentModels.kt b/packages/kotlin/src/commonMain/kotlin/io/agenteract/AgentModels.kt
index 059fdf8..5ef9a1c 100644
--- a/packages/kotlin/src/commonMain/kotlin/io/agenteract/AgentModels.kt
+++ b/packages/kotlin/src/commonMain/kotlin/io/agenteract/AgentModels.kt
@@ -11,7 +11,8 @@ data class AgentCommand(
     val value: String? = null,
     val direction: String? = null,
     val amount: Double? = null,
-    val velocity: String? = null
+    val velocity: String? = null,
+    val payload: String? = null
 )
 
 @Serializable
diff --git a/packages/react/src/AgentDebugBridge.tsx b/packages/react/src/AgentDebugBridge.tsx
index 784fab1..bda63e9 100644
--- a/packages/react/src/AgentDebugBridge.tsx
+++ b/packages/react/src/AgentDebugBridge.tsx
@@ -349,7 +349,7 @@ export function simulateSwipe(
 
 
 // --- Command Handler ---
-const handleCommand = async (cmd: ServerCommand, socket: WebSocket) => {
+const handleCommand = async (cmd: ServerCommand, socket: WebSocket, onAgentLink?: (url: string) => Promise<boolean> | boolean) => {
   if (typeof cmd !== 'object' || !('action' in cmd)) {
     console.log(`Warning: command missing 'action' field: ${JSON.stringify(cmd)}`);
     // Send a generic error back if the command is malformed
@@ -374,21 +374,37 @@ const handleCommand = async (cmd: ServerCommand, socket: WebSocket) => {
     case "swipe":
       success = simulateSwipe(cmd.testID, cmd.direction, cmd.velocity);
       break;
+    case "agentLink":
+      if (onAgentLink) {
+        try {
+          const result = await onAgentLink(cmd.payload);
+          success = result === true;
+        } catch (error) {
+          console.warn('[Agenteract] agentLink handler error:', error);
+          success = false;
+        }
+      } else {
+        console.warn('[Agenteract] agentLink received but no onAgentLink handler provided');
+        success = false;
+      }
+      break;
     default:
       socket.send(JSON.stringify({ status: "error", error: `Unknown action ${cmd.action}`, id: cmd.id }));
       return;
   }
-  
+
   socket.send(JSON.stringify({ status: success ? "ok" : "error", action: cmd.action, id: cmd.id }));
 };
 
 // --- AgentDebugBridge Component ---
 export const AgentDebugBridge = ({
   projectName,
-  autoConnect = true
+  autoConnect = true,
+  onAgentLink
 }: {
   projectName: string;
   autoConnect?: boolean;
+  onAgentLink?: (url: string) => Promise<boolean> | boolean;
 }) => {
   const socketRef = useRef<WebSocket | null>(null);
   const timeoutRef = useRef<number | null>(null);
@@ -440,22 +456,31 @@ export const AgentDebugBridge = ({
   useEffect(() => {
     if (getPlatform() === 'web') return; // Skip for web
 
-    // Handle initial URL (app opened via deep link)
+    // Handle initial URL (app opened via agent link)
     Linking.getInitialURL().then((url: string | null) => {
-      if (url) handleDeepLink(url);
+      if (url) handleAgentLink(url);
     });
 
     // Handle URL when app is already open
     const subscription = Linking.addEventListener('url', (event: { url: string }) => {
-      handleDeepLink(event.url);
+      handleAgentLink(event.url);
     });
 
     return () => subscription?.remove();
-  }, []);
+  }, [onAgentLink]);
 
-  const handleDeepLink = async (url: string) => {
+  const handleAgentLink = async (url: string) => {
     try {
-      console.log('[Agenteract] Received deep link:', url);
+      console.log('[Agenteract] Received agent link:', url);
+
+      // First, check if app has a custom agent link handler
+      if (onAgentLink) {
+        const handled = await Promise.resolve(onAgentLink(url));
+        if (handled) {
+          console.log('[Agenteract] Agent link handled by app');
+          return;
+        }
+      }
 
       // Parse URL - supports both exp://*/agenteract/config and custom schemes
       // Examples:
@@ -640,7 +665,7 @@ export const AgentDebugBridge = ({
           } else if (command.action === 'getConsoleLogs') {
             socket.send(JSON.stringify({ status: 'success', logs: logBuffer, id: command.id }));
           } else {
-            await handleCommand(command, socket);
+            await handleCommand(command, socket, onAgentLink);
           }
         } catch (error) {
           console.warn('[Agenteract] Command error:', error);
@@ -666,7 +691,7 @@ export const AgentDebugBridge = ({
       console.log('[Agenteract] Failed to create WebSocket:', error);
       socketRef.current = null;
     }
-  }, [projectName, serverUrl, authToken, deviceId, shouldConnect]);
+  }, [projectName, serverUrl, authToken, deviceId, shouldConnect, onAgentLink]);
 
   useEffect(() => {
     connect();
diff --git a/packages/server/jest.config.cjs b/packages/server/jest.config.cjs
index 0a377fa..6620d54 100644
--- a/packages/server/jest.config.cjs
+++ b/packages/server/jest.config.cjs
@@ -5,5 +5,6 @@ module.exports = {
   testPathIgnorePatterns: ['/node_modules/', '/dist/'],
   moduleNameMapper: {
     '^express$': '<rootDir>/../../node_modules/express',
+    '^(\\.{1,2}/.*)\\.js$': '$1',
   },
 };
diff --git a/packages/server/package.json b/packages/server/package.json
index 02b05c7..5dd71e2 100644
--- a/packages/server/package.json
+++ b/packages/server/package.json
@@ -49,4 +49,4 @@
     "jest": "^30.2.0",
     "ts-jest": "^29.4.5"
   }
-}
+}
\ No newline at end of file
diff --git a/packages/server/src/index.ts b/packages/server/src/index.ts
index c20733a..209470d 100644
--- a/packages/server/src/index.ts
+++ b/packages/server/src/index.ts
@@ -8,7 +8,9 @@ import express from 'express';
 import url from 'url';
 import { spawn, ChildProcess } from 'child_process';
 
-import { generateAuthToken, saveRuntimeConfig, loadRuntimeConfig, DeviceInfoSummary } from '@agenteract/core/node';
+import { generateAuthToken, saveRuntimeConfig, loadRuntimeConfig, DeviceInfoSummary, loadConfig, findConfigRoot } from '@agenteract/core/node';
+import { runTest } from './test-runner.js';
+import type { TestDefinition } from './test-types.js';
 
 const isLogServer = process.argv.includes('--log-only');
 
@@ -405,10 +407,19 @@ if (isLogServer) {
             pendingDeviceInfo.set(projectName, ws);
 
             ws.on('message', (message: Buffer) => {
-                console.log(`[DEBUG] Received raw message from "${projectName}": ${message.toString()}`);
-                log(`Received message from "${projectName}": ${message.toString()}`);
                 try {
                     const response = JSON.parse(message.toString());
+                    
+                    // Only log non-hierarchy messages to reduce spam
+                    // Hierarchy responses are typically very large (>10KB), so skip logging them
+                    const isHierarchyResponse = response.hierarchy !== undefined;
+                    const isLargeMessage = message.length > 10000;
+                    if (!isHierarchyResponse && !isLargeMessage) {
+                        console.log(`[DEBUG] Received raw message from "${projectName}": ${message.toString()}`);
+                        log(`Received message from "${projectName}": ${message.toString()}`);
+                    } else {
+                        console.log(`[DEBUG] Received hierarchy response from "${projectName}" (${message.length} bytes, SUPPRESSED)`);
+                    }
 
                     // Check if this is device info
                     if (response.status === 'deviceInfo' && response.deviceInfo) {
@@ -465,7 +476,11 @@ if (isLogServer) {
 
                     // Handle command responses
                     if (response.id && pendingRequests.has(response.id)) {
-                        console.log(`[DEBUG] Received response from ${projectName}, id: ${response.id}, status: ${response.status}`);
+                        // Only log non-hierarchy responses to reduce spam
+                        const isHierarchyResponse = response.hierarchy !== undefined;
+                        if (!isHierarchyResponse) {
+                            console.log(`[DEBUG] Received response from ${projectName}, id: ${response.id}, status: ${response.status}`);
+                        }
                         const res = pendingRequests.get(response.id)!;
                         res.writeHead(200, { 'Content-Type': 'application/json' });
                         res.end(JSON.stringify(response));
@@ -670,6 +685,131 @@ if (isLogServer) {
             });
         });
 
+        // --- Test Runner Endpoint ---
+        app.post('/test-run', async (req, res) => {
+            const testDefinition = req.body as TestDefinition;
+
+            if (!testDefinition.project) {
+                return res.status(400).json({ error: 'Test definition must include a "project" field.' });
+            }
+
+            if (!testDefinition.steps || !Array.isArray(testDefinition.steps)) {
+                return res.status(400).json({ error: 'Test definition must include a "steps" array.' });
+            }
+
+            log(`Starting test run for project "${testDefinition.project}" with ${testDefinition.steps.length} steps`);
+
+            // Helper to send command and wait for response
+            const sendCommand = async (command: Record<string, unknown>): Promise<Record<string, unknown>> => {
+                const projectName = command.project as string;
+                const requestedDevice = command.device as string | undefined;
+
+                const result = await resolveDeviceConnection(projectName, requestedDevice);
+                if ('error' in result) {
+                    throw new Error(result.error);
+                }
+
+                const { connection } = result;
+                const id = uuidv4();
+                command.id = id;
+
+                return new Promise((resolve, reject) => {
+                    const timeout = setTimeout(() => {
+                        pendingRequests.delete(id);
+                        reject(new Error('Timed out waiting for response from app'));
+                    }, 10000);
+
+                    // Create a fake response object to capture the result
+                    const fakeRes = {
+                        writeHead: () => {},
+                        end: (data: string) => {
+                            clearTimeout(timeout);
+                            pendingRequests.delete(id);
+                            try {
+                                resolve(JSON.parse(data));
+                            } catch {
+                                resolve({ status: 'ok' });
+                            }
+                        }
+                    } as unknown as http.ServerResponse;
+
+                    pendingRequests.set(id, fakeRes);
+                    connection.socket.send(JSON.stringify(command));
+                });
+            };
+
+            // Helper to get hierarchy
+            const getHierarchy = async () => {
+                const response = await sendCommand({
+                    project: testDefinition.project,
+                    action: 'getViewHierarchy',
+                    device: testDefinition.device,
+                });
+                return response.hierarchy as any || null;
+            };
+
+            // Helper to get logs
+            const getLogs = async (since: number = 50) => {
+                try {
+                    const response = await sendCommand({
+                        project: testDefinition.project,
+                        action: 'getConsoleLogs',
+                        device: testDefinition.device,
+                    });
+                    const logs = (response.logs as any[]) || [];
+                    // Log the retrieved logs to server console for CI visibility
+                    console.log(`[Test] Retrieved ${logs.length} logs from app`);
+                    if (logs.length > 0) {
+                        const lastLog = logs[logs.length - 1];
+                        console.log(`[Test] Latest log from app: [${lastLog.level}] ${lastLog.message} (@${lastLog.timestamp})`);
+                    }
+                    return logs;
+                } catch (e) {
+                    console.error(`[Test] Failed to get logs: ${e}`);
+                    return [];
+                }
+            };
+
+            try {
+                // Load config to get project path and lifecycle config
+                let projectPath: string | undefined;
+                let lifecycleConfig: any | undefined;
+                try {
+                    const configRoot = await findConfigRoot();
+                    if (configRoot) {
+                        const config = await loadConfig(configRoot);
+                        const project = config.projects.find(p => p.name === testDefinition.project);
+                        if (project) {
+                            projectPath = path.isAbsolute(project.path)
+                                ? project.path
+                                : path.join(configRoot, project.path);
+                            lifecycleConfig = project.lifecycle;
+                        }
+                    }
+                } catch (error) {
+                    console.warn(`[Test] Could not load project path: ${error}`);
+                }
+
+                const result = await runTest(testDefinition, {
+                    sendCommand,
+                    getHierarchy,
+                    getLogs,
+                    projectPath,
+                    lifecycleConfig,
+                    log: (message: string) => {
+                        console.log(`[Test] ${message}`);
+                    },
+                });
+
+                res.json(result);
+            } catch (error) {
+                res.status(500).json({
+                    status: 'failed',
+                    error: error instanceof Error ? error.message : String(error),
+                });
+            }
+        });
+
         app.listen(HTTP_PORT, '0.0.0.0', () => {
             log(`HTTP server for commands listening on port ${HTTP_PORT}`);
             console.log(`Agenteract server running. Apps connect to ws://localhost:${WS_PORT}/{projectName}. Press Ctrl+C to stop.`);
diff --git a/packages/server/src/test-runner.ts b/packages/server/src/test-runner.ts
new file mode 100644
index 0000000..7444ebd
--- /dev/null
+++ b/packages/server/src/test-runner.ts
@@ -0,0 +1,946 @@
+/**
+ * Test Runner Engine
+ *
+ * Executes YAML test definitions server-side, reducing round-trips
+ * by handling waitFor polling and assertions internally.
+ */
+
+import { v4 as uuidv4 } from 'uuid';
+import { execSync } from 'child_process';
+import {
+  TestDefinition,
+  TestResult,
+  StepResult,
+  Step,
+  isTapStep,
+  isInputStep,
+  isWaitForStep,
+  isAssertStep,
+  isScrollStep,
+  isSwipeStep,
+  isLongPressStep,
+  isSleepStep,
+  isLogStep,
+  isPhaseStep,
+  isLaunchStep,
+  isStopStep,
+  isSetupStep,
+  isBuildStep,
+  isAgentLinkStep,
+  isPairStep,
+  isCustomStep,
+  getStepAction,
+  getStepTarget,
+  AssertExistsCondition,
+  AssertNotExistsCondition,
+  AssertTextCondition,
+  AssertLogCondition,
+} from './test-types.js';
+import {
+  detectPlatform,
+  PlatformInfo,
+  resolveBundleIds,
+  BundleInfo,
+  selectDevice,
+  Device,
+  launchApp,
+  stopApp,
+  buildApp,
+  performSetup,
+  LaunchResult,
+} from '@agenteract/core/node';
+
+// Hierarchy node from app
+interface HierarchyNode {
+  name?: string;
+  testID?: string;
+  text?: string;
+  children?: HierarchyNode[];
+  [key: string]: unknown;
+}
+
+// Function to send command and wait for response
+type SendCommandFn = (command: Record<string, unknown>) => Promise<Record<string, unknown>>;
+
+// Function to get hierarchy
+type GetHierarchyFn = () => Promise<HierarchyNode | null>;
+
+// Function to get logs
+type GetLogsFn = (since?: number) => Promise<Array<{ level: string; message: string; timestamp: number }>>;
+
+export interface TestRunnerContext {
+  project: string;
+  device?: string;
+  projectPath?: string;
+  runtimeTarget?: 'ios' | 'android' | 'native';
+  lifecycleConfig?: {
+    bundleId?: {
+      ios?: string;
+      android?: string;
+    };
+    mainActivity?: string;
+    launchTimeout?: number;
+    requiresInstall?: boolean;
+  };
+  sendCommand: SendCommandFn;
+  getHierarchy: GetHierarchyFn;
+  getLogs: GetLogsFn;
+  defaultTimeout: number;
+  log: (message: string) => void;
+  lifecycleState?: {
+    platform?: PlatformInfo;
+    bundleInfo?: BundleInfo;
+    selectedDevice?: Device;
+    launchResult?: LaunchResult;
+  };
+}
+
+/**
+ * Find a node in the hierarchy by testID
+ */
+function findNodeByTestID(node: HierarchyNode | null, testID: string): HierarchyNode | null {
+  if (!node) return null;
+
+  if (node.testID === testID) {
+    return node;
+  }
+
+  if (node.children) {
+    for (const child of node.children) {
+      const found = findNodeByTestID(child, testID);
+      if (found) return found;
+    }
+  }
+
+  return null;
+}
+
+/**
+ * Get text content from a node (including nested Text children)
+ */
+function getNodeText(node: HierarchyNode): string | null {
+  if (node.text) return node.text;
+  
+  // For Swift/iOS: fall back to accessibilityLabel if no text property
+  // SwiftUI Text views often only expose text via accessibilityLabel
+  if ((node as any).accessibilityLabel) {
+    return (node as any).accessibilityLabel;
+  }
+
+  // Collect text from child Text nodes
+  const collectText = (n: HierarchyNode): string[] => {
+    const texts: string[] = [];
+    // Check both 'type' (Flutter) and 'name' (other platforms) properties
+    const nodeType = (n as any).type || n.name;
+    if (n.text && nodeType === 'Text') {
+      texts.push(n.text);
+    }
+    if (n.children) {
+      for (const child of n.children) {
+        texts.push(...collectText(child));
+      }
+    }
+    return texts;
+  };
+
+  const childTexts = collectText(node);
+  return childTexts.length > 0 ? childTexts.join(' ') : null;
+}
+
+/**
+ * Check if hierarchy contains a testID (searches full JSON string for speed)
+ */
+function hierarchyContainsTestID(hierarchy: HierarchyNode | null, testID: string): boolean {
+  if (!hierarchy) return false;
+  // Fast path: search the serialized hierarchy
+  const json = JSON.stringify(hierarchy);
+  return json.includes(`"testID":"${testID}"`);
+}
+
+/**
+ * Execute a single step
+ */
+async function executeStep(
+  step: Step,
+  stepIndex: number,
+  ctx: TestRunnerContext
+): Promise<StepResult> {
+  const startTime = Date.now();
+  const action = getStepAction(step);
+  const target = getStepTarget(step);
+
+  // Format step for logging
+  const stepStr = JSON.stringify(step, null, 2).split('\n').map(line => `  ${line}`).join('\n');
+  console.log(`[Test] Step ${stepIndex}: ${action} ${target ? `(${target})` : ''}`);
+  console.log(`[Test] Step definition:\n${stepStr}`);
+
+  try {
+    // Handle each step type
+    if (isTapStep(step)) {
+      await ctx.sendCommand({
+        project: ctx.project,
+        action: 'tap',
+        testID: step.tap,
+        device: ctx.device,
+      });
+
+      if (step.wait && step.wait > 0) {
+        await sleep(step.wait);
+      }
+
+      return {
+        step: stepIndex,
+        action,
+        target,
+        status: 'passed',
+        duration: Date.now() - startTime,
+        stepDefinition: step,
+      };
+    }
+
+    if (isInputStep(step)) {
+      // Resolve environment variables in value
+      let value = step.value;
+      const envMatch = value.match(/\$\{\{\s*env\.(\w+)\s*\}\}/);
+      if (envMatch) {
+        const envVar = process.env[envMatch[1]];
+        if (envVar === undefined) {
+          throw new Error(`Environment variable ${envMatch[1]} is not set`);
+        }
+        value = value.replace(envMatch[0], envVar);
+      }
+
+      await ctx.sendCommand({
+        project: ctx.project,
+        action: 'input',
+        testID: step.input,
+        value,
+        device: ctx.device,
+      });
+
+      return {
+        step: stepIndex,
+        action,
+        target,
+        status: 'passed',
+        duration: Date.now() - startTime,
+        stepDefinition: step,
+      };
+    }
+
+    if (isWaitForStep(step)) {
+      const timeout = step.timeout || ctx.defaultTimeout;
+      const pollInterval = 500;
+      const startWait = Date.now();
+
+      // Wait for console log to appear
+      if (step.logContains) {
+        console.log(`[Test] Waiting for log containing: "${step.logContains}"`);
+        let pollCount = 0;
+        while (Date.now() - startWait < timeout) {
+          pollCount++;
+          const logs = await ctx.getLogs();  // Get all logs, not since timestamp 30
+          console.log(`[Test] Poll ${pollCount}: Got ${logs.length} logs`);
+          if (logs.length > 0) {
+            console.log(`[Test] Poll ${pollCount} last log: ${logs[logs.length - 1].message}`);
+          }
+          const logText = logs.map(l => l.message).join('\n');
+          
+          if (logText.includes(step.logContains)) {
+            console.log(`[Test] ✓ Found log containing: "${step.logContains}"`);
+            return {
+              step: stepIndex,
+              action,
+              target: step.logContains,
+              status: 'passed',
+              duration: Date.now() - startTime,
+            };
+          }
+
+          console.log(`[Test] Log not found yet, waiting ${pollInterval}ms...`);
+          await sleep(pollInterval);
+        }
+
+        throw new Error(`Timeout waiting for log: "${step.logContains}"`);
+      }
+
+      // Wait for element (with optional text match)
+      if (!step.waitFor || step.waitFor === "") {
+        throw new Error('waitFor step requires either "waitFor" (testID) or "logContains"');
+      }
+
+      console.log(`[Test] Waiting for element: "${step.waitFor}"${step.text ? ` with text "${step.text}"` : ''}`);
+      let pollCount = 0;
+      while (Date.now() - startWait < timeout) {
+        pollCount++;
+        if (pollCount % 5 === 1) {  // Log every 5th poll to reduce spam
+          console.log(`[Test] Poll ${pollCount}: Checking hierarchy for "${step.waitFor}"...`);
+        }
+        const hierarchy = await ctx.getHierarchy();
+
+        if (step.text) {
+          // Wait for element with specific text
+          const node = findNodeByTestID(hierarchy, step.waitFor);
+          if (node) {
+            const nodeText = getNodeText(node);
+            if (nodeText && nodeText.includes(step.text)) {
+              console.log(`[Test] ✓ Found element "${step.waitFor}" with text "${step.text}"`);
+              return {
+                step: stepIndex,
+                action,
+                target,
+                status: 'passed',
+                duration: Date.now() - startTime,
+              };
+            }
+          }
+        } else {
+          // Wait for element to exist
+          if (hierarchyContainsTestID(hierarchy, step.waitFor)) {
+            console.log(`[Test] ✓ Found element "${step.waitFor}"`);
+            return {
+              step: stepIndex,
+              action,
+              target,
+              status: 'passed',
+              duration: Date.now() - startTime,
+            };
+          }
+        }
+
+        await sleep(pollInterval);
+      }
+
+      throw new Error(`Timeout waiting for element: ${step.waitFor}${step.text ? ` with text "${step.text}"` : ''}`);
+    }
+
+    if (isAssertStep(step)) {
+      const condition = step.assert;
+      let conditionStr: string;
+
+      if ('exists' in condition) {
+        conditionStr = `exists:${(condition as AssertExistsCondition).exists}`;
+        const hierarchy = await ctx.getHierarchy();
+        if (!hierarchyContainsTestID(hierarchy, (condition as AssertExistsCondition).exists)) {
+          throw new Error(`Element not found: ${(condition as AssertExistsCondition).exists}`);
+        }
+      } else if ('notExists' in condition) {
+        conditionStr = `notExists:${(condition as AssertNotExistsCondition).notExists}`;
+        const hierarchy = await ctx.getHierarchy();
+        if (hierarchyContainsTestID(hierarchy, (condition as AssertNotExistsCondition).notExists)) {
+          throw new Error(`Element should not exist: ${(condition as AssertNotExistsCondition).notExists}`);
+        }
+      } else if ('text' in condition) {
+        const textCond = (condition as AssertTextCondition).text;
+        conditionStr = `text:${textCond.testID}`;
+        const hierarchy = await ctx.getHierarchy();
+        const node = findNodeByTestID(hierarchy, textCond.testID);
+        if (!node) {
+          throw new Error(`Element not found for text assertion: ${textCond.testID}`);
+        }
+        const nodeText = getNodeText(node);
+        if (textCond.contains && (!nodeText || !nodeText.includes(textCond.contains))) {
+          throw new Error(`Text "${nodeText || ''}" does not contain "${textCond.contains}"`);
+        }
+        if (textCond.equals && nodeText !== textCond.equals) {
+          throw new Error(`Text "${nodeText || ''}" does not equal "${textCond.equals}"`);
+        }
+      } else if ('logContains' in condition) {
+        conditionStr = `logContains:${(condition as AssertLogCondition).logContains}`;
+        const logs = await ctx.getLogs();  // Get all logs, not since timestamp 30
+        const logText = logs.map(l => l.message).join('\n');
+        if (!logText.includes((condition as AssertLogCondition).logContains)) {
+          throw new Error(`Logs do not contain: ${(condition as AssertLogCondition).logContains}`);
+        }
+      } else {
+        throw new Error('Unknown assert condition');
+      }
+
+      return {
+        step: stepIndex,
+        action,
+        condition: conditionStr,
+        status: 'passed',
+        duration: Date.now() - startTime,
+        stepDefinition: step,
+      };
+    }
+
+    if (isScrollStep(step)) {
+      await ctx.sendCommand({
+        project: ctx.project,
+        action: 'scroll',
+        testID: step.scroll,
+        direction: step.direction,
+        amount: step.amount || 100,
+        device: ctx.device,
+      });
+
+      return {
+        step: stepIndex,
+        action,
+        target,
+        status: 'passed',
+        duration: Date.now() - startTime,
+        stepDefinition: step,
+      };
+    }
+
+    if (isSwipeStep(step)) {
+      await ctx.sendCommand({
+        project: ctx.project,
+        action: 'swipe',
+        testID: step.swipe,
+        direction: step.direction,
+        velocity: step.velocity || 'medium',
+        device: ctx.device,
+      });
+
+      return {
+        step: stepIndex,
+        action,
+        target,
+        status: 'passed',
+        duration: Date.now() - startTime,
+        stepDefinition: step,
+      };
+    }
+
+    if (isLongPressStep(step)) {
+      await ctx.sendCommand({
+        project: ctx.project,
+        action: 'longPress',
+        testID: step.longPress,
+        device: ctx.device,
+      });
+
+      return {
+        step: stepIndex,
+        action,
+        target,
+        status: 'passed',
+        duration: Date.now() - startTime,
+        stepDefinition: step,
+      };
+    }
+
+    if (isSleepStep(step)) {
+      await sleep(step.sleep);
+
+      return {
+        step: stepIndex,
+        action,
+        target: `${step.sleep}ms`,
+        status: 'passed',
+        duration: Date.now() - startTime,
+      };
+    }
+
+    if (isLogStep(step)) {
+      ctx.log(step.log);
+
+      return {
+        step: stepIndex,
+        action,
+        target: step.log,
+        status: 'passed',
+        duration: Date.now() - startTime,
+      };
+    }
+
+    if (isPhaseStep(step)) {
+      console.log(`\n[Test] --- Phase: ${step.phase} ---\n`);
+      ctx.log(`--- Phase: ${step.phase} ---`);
+
+      return {
+        step: stepIndex,
+        action,
+        target: step.phase,
+        status: 'passed',
+        duration: Date.now() - startTime,
+      };
+    }
+
+    if (isLaunchStep(step)) {
+      if (!ctx.projectPath) {
+        throw new Error('Project path is required for launch step');
+      }
+
+      // 1. Detect platform
+      const platformInfo = await detectPlatform(ctx.projectPath);
+      console.log(`[Test] Detected platform: ${platformInfo.type}`);
+
+      // 2. Extract bundle IDs
+      const bundleInfo = await resolveBundleIds(ctx.projectPath, platformInfo.type, ctx.lifecycleConfig);
+      console.log(`[Test] Bundle IDs:`, bundleInfo);
+
+      // 3. Select device
+      const platformForDevice = platformInfo.type.includes('android')
+        ? 'android'
+        : platformInfo.type === 'kmp-desktop'
+        ? 'desktop'
+        : platformInfo.type === 'vite'
+        ? 'web'
+        : 'ios';
+
+      const device = await selectDevice(step.device || ctx.device, platformForDevice);
+
+      if (!device) {
+        throw new Error(`No device available for platform ${platformInfo.type}`);
+      }
+
+      console.log(`[Test] Selected device:`, device);
+
+      // 4. Launch app
+      const launchResult = await launchApp(
+        platformInfo.type,
+        device,
+        bundleInfo,
+        ctx.projectPath,
+        { timeout: step.timeout, waitForReady: step.waitForReady }
+      );
+
+      console.log(`[Test] App launched successfully`);
+
+      // 5. Store state for cleanup
+      ctx.lifecycleState = {
+        platform: platformInfo,
+        bundleInfo,
+        selectedDevice: device || undefined,
+        launchResult,
+      };
+
+      // 6. Wait for connection if requested
+      if (step.waitForReady !== false) {
+        const connectionTimeout = step.timeout || 60000;
+        const pollInterval = 1000;
+        const startWait = Date.now();
+
+        console.log(`[Test] Waiting for app connection (timeout: ${connectionTimeout}ms)...`);
+
+        while (Date.now() - startWait < connectionTimeout) {
+          try {
+            const hierarchy = await ctx.getHierarchy();
+            if (hierarchy) {
+              console.log(`[Test] App connected successfully`);
+              break;
+            }
+          } catch (error) {
+            // App not connected yet
+          }
+
+          if (Date.now() - startWait >= connectionTimeout) {
+            throw new Error(`Timeout waiting for app connection (${connectionTimeout}ms)`);
+          }
+
+          await sleep(pollInterval);
+        }
+      }
+
+      return {
+        step: stepIndex,
+        action,
+        target,
+        status: 'passed',
+        duration: Date.now() - startTime,
+        stepDefinition: step,
+      };
+    }
+
+    if (isStopStep(step)) {
+      if (!ctx.lifecycleState || !ctx.lifecycleState.platform || !ctx.lifecycleState.bundleInfo) {
+        throw new Error('No app is running. Use launch step first.');
+      }
+
+      const force = step.stop === 'kill';
+      await stopApp(
+        ctx.lifecycleState.platform.type,
+        ctx.lifecycleState.selectedDevice || null,
+        ctx.lifecycleState.bundleInfo,
+        ctx.lifecycleState.launchResult,
+        force
+      );
+
+      console.log(`[Test] App stopped (${force ? 'force' : 'graceful'})`);
+
+      return {
+        step: stepIndex,
+        action,
+        target,
+        status: 'passed',
+        duration: Date.now() - startTime,
+        stepDefinition: step,
+      };
+    }
+
+    if (isSetupStep(step)) {
+      if (!ctx.projectPath) {
+        throw new Error('Project path is required for setup step');
+      }
+
+      if (!ctx.lifecycleState) {
+        // Initialize lifecycle state if not already done
+        const platformInfo = await detectPlatform(ctx.projectPath);
+        const bundleInfo = await resolveBundleIds(ctx.projectPath, platformInfo.type, ctx.lifecycleConfig);
+        const platformForDevice = platformInfo.type.includes('android')
+          ? 'android'
+          : platformInfo.type === 'kmp-desktop'
+          ? 'desktop'
+          : platformInfo.type === 'vite'
+          ? 'web'
+          : 'ios';
+        const device = await selectDevice(ctx.device, platformForDevice);
+
+        ctx.lifecycleState = {
+          platform: platformInfo,
+          bundleInfo,
+          selectedDevice: device || undefined,
+        };
+      }
+
+      await performSetup(
+        ctx.projectPath,
+        ctx.lifecycleState.platform!.type,
+        ctx.lifecycleState.selectedDevice || null,
+        ctx.lifecycleState.bundleInfo!,
+        { action: step.setup, platform: step.platform }
+      );
+
+      console.log(`[Test] Setup completed: ${step.setup}`);
+
+      return {
+        step: stepIndex,
+        action,
+        target: step.setup,
+        status: 'passed',
+        duration: Date.now() - startTime,
+      };
+    }
+
+    if (isBuildStep(step)) {
+      if (!ctx.projectPath) {
+        throw new Error('Project path is required for build step');
+      }
+
+      if (!ctx.lifecycleState) {
+        const platformInfo = await detectPlatform(ctx.projectPath);
+        ctx.lifecycleState = { platform: platformInfo };
+      }
+
+      await buildApp(
+        ctx.projectPath,
+        ctx.lifecycleState.platform!.type,
+        { configuration: step.build, platform: step.platform }
+      );
+
+      console.log(`[Test] Build completed: ${step.build}`);
+
+      return {
+        step: stepIndex,
+        action,
+        target: step.build,
+        status: 'passed',
+        duration: Date.now() - startTime,
+      };
+    }
+
+    if (isAgentLinkStep(step)) {
+      // Send agentLink payload via AgentDebugBridge
+      await ctx.sendCommand({
+        project: ctx.project,
+        action: 'agentLink',
+        payload: step.agentLink,
+        device: ctx.device,
+      });
+
+      // Optional: wait for response if timeout specified
+      if (step.timeout) {
+        await sleep(step.timeout);
+      }
+
+      console.log(`[Test] AgentLink sent: ${step.agentLink}`);
+
+      return {
+        step: stepIndex,
+        action,
+        target: step.agentLink,
+        status: 'passed',
+        duration: Date.now() - startTime,
+      };
+    }
+
+    if (isPairStep(step)) {
+      // For native/desktop apps, pairing is not needed - they auto-connect via localhost
+      if (ctx.runtimeTarget === 'native') {
+        console.log(`[Test] Skipping pairing for native/desktop app (runtime target: native)`);
+        console.log(`[Test] Native apps auto-connect to localhost without authentication`);
+        
+        // Still validate server is running by loading runtime config
+        const { loadRuntimeConfig } = await import('@agenteract/core/node');
+        let runtimeConfig = await loadRuntimeConfig();
+        if (!runtimeConfig) {
+          if (ctx.projectPath) {
+            const { dirname } = await import('path');
+            runtimeConfig = await loadRuntimeConfig(dirname(ctx.projectPath));
+          }
+        }
+        
+        if (!runtimeConfig) {
+          throw new Error('Runtime config not found. Is the Agenteract dev server running?');
+        }
+        
+        console.log(`[Test] Server validated - listening on port ${runtimeConfig.port}`);
+        
+        // Wait briefly to ensure app has connected
+        const waitTime = step.timeout || 2000;
+        console.log(`[Test] Waiting ${waitTime}ms for native app to connect...`);
+        await sleep(waitTime);
+        
+        return {
+          step: stepIndex,
+          action,
+          target: 'native-desktop',
+          status: 'passed',
+          duration: Date.now() - startTime,
+          stepDefinition: step,
+        };
+      }
+      
+      // Generate and send pairing deep link to simulator/emulator
+      // This tests deep link pairing for app initialization
+      
+      const { loadConfig, loadRuntimeConfig, findConfigRoot } = await import('@agenteract/core/node');
+      
+      // Load runtime config - try current working directory first, then fall back to where the server was started
+      // The runtime config is stored where `agenteract dev` was started
+      let runtimeConfig = await loadRuntimeConfig();
+      if (!runtimeConfig) {
+        // If not found in default location, try from projectPath parent (common pattern in tests)
+        if (ctx.projectPath) {
+          const { dirname } = await import('path');
+          runtimeConfig = await loadRuntimeConfig(dirname(ctx.projectPath));
+        }
+      }
+      
+      if (!runtimeConfig) {
+        throw new Error('Runtime config not found. Is the Agenteract dev server running?');
+      }
+
+      // Load project config - try current directory first, then projectPath
+      let configRoot = await findConfigRoot();
+      if (!configRoot && ctx.projectPath) {
+        configRoot = await findConfigRoot(ctx.projectPath);
+      }
+      
+      if (!configRoot) {
+        throw new Error('Could not find agenteract.config.js');
+      }
+
+      const agenteractConfig = await loadConfig(configRoot);
+      const project = agenteractConfig.projects.find(p => p.name === ctx.project);
+      if (!project || !project.scheme) {
+        throw new Error(`Project "${ctx.project}" not found or has no scheme configured`);
+      }
+
+      const scheme = project.scheme;
+      
+      // Determine host based on device type
+      // For simulators/emulators, use localhost
+      // For physical devices, we'd need to use the machine's IP address
+      const host = step.pair === 'physical' ? 'REQUIRES_MACHINE_IP' : 'localhost';
+      
+      // Generate pairing deep link
+      let pairingUrl: string;
+      if (scheme === 'exp' || scheme === 'exps') {
+        // Expo Go format
+        const expoPort = 8081;
+        pairingUrl = `${scheme}://${host}:${expoPort}/--/agenteract/config?host=${host}&port=${runtimeConfig.port}&token=${runtimeConfig.token}`;
+      } else {
+        // Standard deep link format
+        pairingUrl = `${scheme}://agenteract/config?host=${host}&port=${runtimeConfig.port}&token=${runtimeConfig.token}`;
+      }
+
+      console.log(`[Test] Pairing with ${step.pair} device using deep link: ${pairingUrl}`);
+
+      // Send deep link to device based on platform
+      if (step.platform === 'ios' && step.pair === 'simulator') {
+        try {
+          // Use xcrun simctl openurl to send deep link to iOS Simulator
+          // Use stdio: 'pipe' to avoid hanging in CI environments
+          const output = execSync(`xcrun simctl openurl booted "${pairingUrl}"`, { stdio: 'pipe' });
+          if (output && output.length > 0) {
+            console.log(`[Test] xcrun output: ${output.toString()}`);
+          }
+          console.log(`[Test] Sent pairing deep link to iOS Simulator`);
+        } catch (error) {
+          throw new Error(`Failed to send deep link to iOS Simulator: ${error instanceof Error ? error.message : String(error)}`);
+        }
+      } else if (step.platform === 'android' && step.pair === 'emulator') {
+        try {
+          // Use adb to send deep link to Android Emulator
+          // Use stdio: 'pipe' to avoid hanging in CI environments
+          const output = execSync(`adb shell am start -a android.intent.action.VIEW -d "${pairingUrl}"`, { stdio: 'pipe' });
+          if (output && output.length > 0) {
+            console.log(`[Test] adb output: ${output.toString()}`);
+          }
+          console.log(`[Test] Sent pairing deep link to Android Emulator`);
+        } catch (error) {
+          throw new Error(`Failed to send deep link to Android Emulator: ${error instanceof Error ? error.message : String(error)}`);
+        }
+      } else if (step.pair === 'physical') {
+        // For physical devices, we just log the URL - user needs to scan QR code manually
+        console.log(`[Test] Physical device pairing URL generated. User must scan QR code.`);
+        console.log(`[Test] URL: ${pairingUrl}`);
+      } else {
+        throw new Error(`Unsupported pairing configuration: platform=${step.platform}, type=${step.pair}`);
+      }
+
+      // Wait for connection (give app time to process deep link and connect)
+      const waitTime = step.timeout || 5000;
+      console.log(`[Test] Waiting ${waitTime}ms for app to pair...`);
+      await sleep(waitTime);
+
+      return {
+        step: stepIndex,
+        action,
+        target: `${step.pair}-${step.platform || 'auto'}`,
+        status: 'passed',
+        duration: Date.now() - startTime,
+      };
+    }
+
+    if (isCustomStep(step)) {
+      // Custom steps require TypeScript extensions - not implemented in MVP
+      throw new Error('Custom steps require TypeScript extensions (not yet implemented)');
+    }
+
+    throw new Error(`Unknown step type: ${action}`);
+  } catch (error) {
+    const errorMessage = error instanceof Error ? error.message : String(error);
+    console.error(`[Test] ❌ Step ${stepIndex} FAILED: ${action} ${target ? `(${target})` : ''}`);
+    console.error(`[Test] Error: ${errorMessage}`);
+    console.error(`[Test] Failed step definition:\n${JSON.stringify(step, null, 2)}`);
+    
+    return {
+      step: stepIndex,
+      action,
+      target,
+      status: 'failed',
+      duration: Date.now() - startTime,
+      error: errorMessage,
+      stepDefinition: step,
+    };
+  }
+}
+
+/**
+ * Run a test definition
+ */
+export async function runTest(
+  definition: TestDefinition,
+  ctx: Omit<TestRunnerContext, 'project' | 'device' | 'defaultTimeout'>
+): Promise<TestResult> {
+  const startTime = Date.now();
+  const results: StepResult[] = [];
+  const logs: Array<{ level: string; message: string; timestamp: number }> = [];
+
+  const fullCtx: TestRunnerContext = {
+    ...ctx,
+    project: definition.project,
+    device: definition.device,
+    defaultTimeout: definition.timeout || 10000,
+    runtimeTarget: definition.runtimeTarget,
+  };
+
+  try {
+    for (let i = 0; i < definition.steps.length; i++) {
+      const step = definition.steps[i];
+      const result = await executeStep(step, i + 1, fullCtx);
+      results.push(result);
+
+      if (result.status === 'failed') {
+        // Stop on first failure
+        console.error(`\n[Test] ═══════════════════════════════════════════════════════`);
+        console.error(`[Test] TEST FAILED AT STEP ${i + 1}/${definition.steps.length}`);
+        console.error(`[Test] ═══════════════════════════════════════════════════════`);
+        console.error(`[Test] Action: ${result.action} ${result.target ? `(${result.target})` : ''}`);
+        console.error(`[Test] Error: ${result.error}`);
+        console.error(`[Test] Step definition:\n${JSON.stringify(result.stepDefinition, null, 2)}`);
+        console.error(`[Test] ═══════════════════════════════════════════════════════\n`);
+        
+        // Mark remaining steps as skipped
+        for (let j = i + 1; j < definition.steps.length; j++) {
+          results.push({
+            step: j + 1,
+            action: getStepAction(definition.steps[j]),
+            target: getStepTarget(definition.steps[j]),
+            status: 'skipped',
+            duration: 0,
+            stepDefinition: definition.steps[j],
+          });
+        }
+
+        // Collect recent logs for debugging
+        try {
+          const recentLogs = await fullCtx.getLogs(50);
+          logs.push(...recentLogs);
+        } catch {
+          // Ignore log collection errors
+        }
+
+        return {
+          status: 'failed',
+          duration: Date.now() - startTime,
+          steps: results,
+          logs,
+          failedAt: i + 1,
+          error: result.error,
+        };
+      }
+    }
+
+    // All steps passed
+    console.log(`\n[Test] ═══════════════════════════════════════════════════════`);
+    console.log(`[Test] ✅ ALL TESTS PASSED`);
+    console.log(`[Test] ═══════════════════════════════════════════════════════`);
+    console.log(`[Test] Total steps: ${results.length}`);
+    console.log(`[Test] Duration: ${Date.now() - startTime}ms`);
+    console.log(`[Test] ═══════════════════════════════════════════════════════\n`);
+
+    return {
+      status: 'passed',
+      duration: Date.now() - startTime,
+      steps: results,
+    };
+  } finally {
+    // Cleanup: Ensure browser/app is stopped if test launched it
+    if (fullCtx.lifecycleState?.launchResult) {
+      try {
+        console.log('[Test] Cleaning up launched app/browser...');
+        const { loadConfig, findConfigRoot } = await import('@agenteract/core/node');
+        // Find config root from current working directory (where CLI runs)
+        const configRoot = await findConfigRoot(process.cwd());
+        if (configRoot) {
+          const config = await loadConfig(configRoot);
+          const project = config.projects.find(p => p.name === definition.project);
+          if (project && fullCtx.lifecycleState.platform && fullCtx.lifecycleState.bundleInfo) {
+            await stopApp(
+              fullCtx.lifecycleState.platform.type,
+              fullCtx.lifecycleState.selectedDevice || null,
+              fullCtx.lifecycleState.bundleInfo,
+              fullCtx.lifecycleState.launchResult,
+              false
+            );
+          }
+        }
+      } catch (err) {
+        console.error(`[Test] Error during cleanup: ${err}`);
+        // Don't throw - we're cleaning up
+      }
+    }
+  }
+}
+
+function sleep(ms: number): Promise<void> {
+  return new Promise(resolve => setTimeout(resolve, ms));
+}
diff --git a/packages/server/src/test-types.ts b/packages/server/src/test-types.ts
new file mode 100644
index 0000000..533cf57
--- /dev/null
+++ b/packages/server/src/test-types.ts
@@ -0,0 +1,279 @@
+/**
+ * Test Runner Types
+ *
+ * Type definitions for YAML test definitions and execution results.
+ */
+
+// Step types
+export interface TapStep {
+  tap: string;
+  wait?: number;
+}
+
+export interface InputStep {
+  input: string;
+  value: string;
+}
+
+export interface WaitForStep {
+  waitFor?: string;  // testID - optional if logContains is provided
+  timeout?: number;
+  text?: string;     // wait for element to contain this text
+  logContains?: string;  // wait for console log to contain this string
+}
+
+export interface AssertExistsCondition {
+  exists: string;
+}
+
+export interface AssertNotExistsCondition {
+  notExists: string;
+}
+
+export interface AssertTextCondition {
+  text: {
+    testID: string;
+    contains?: string;
+    equals?: string;
+  };
+}
+
+export interface AssertLogCondition {
+  logContains: string;
+}
+
+export type AssertCondition =
+  | AssertExistsCondition
+  | AssertNotExistsCondition
+  | AssertTextCondition
+  | AssertLogCondition;
+
+export interface AssertStep {
+  assert: AssertCondition;
+}
+
+export interface ScrollStep {
+  scroll: string;
+  direction: 'up' | 'down' | 'left' | 'right';
+  amount?: number;
+}
+
+export interface SwipeStep {
+  swipe: string;
+  direction: 'up' | 'down' | 'left' | 'right';
+  velocity?: 'slow' | 'medium' | 'fast';
+}
+
+export interface LongPressStep {
+  longPress: string;
+}
+
+export interface SleepStep {
+  sleep: number;
+}
+
+export interface LogStep {
+  log: string;
+}
+
+export interface PhaseStep {
+  phase: string;
+}
+
+export interface CustomStep {
+  custom: string;
+  args?: Record<string, unknown>;
+}
+
+export interface LaunchStep {
+  launch: 'app';
+  device?: string;
+  timeout?: number;
+  waitForReady?: boolean;
+}
+
+export interface StopStep {
+  stop: 'app' | 'kill';
+  timeout?: number;
+}
+
+export interface SetupStep {
+  setup: 'install' | 'reinstall' | 'clearData';
+  platform?: 'ios' | 'android';
+}
+
+export interface BuildStep {
+  build: 'debug' | 'release' | string;
+  platform?: 'ios' | 'android' | 'desktop' | 'web';
+}
+
+export interface AgentLinkStep {
+  agentLink: string;
+  timeout?: number;
+}
+
+export interface PairStep {
+  pair: 'simulator' | 'emulator' | 'physical';
+  platform?: 'ios' | 'android';
+  timeout?: number;
+}
+
+export type Step =
+  | TapStep
+  | InputStep
+  | WaitForStep
+  | AssertStep
+  | ScrollStep
+  | SwipeStep
+  | LongPressStep
+  | SleepStep
+  | LogStep
+  | PhaseStep
+  | LaunchStep
+  | StopStep
+  | SetupStep
+  | BuildStep
+  | AgentLinkStep
+  | PairStep
+  | CustomStep;
+
+// Test definition
+export interface TestDefinition {
+  project: string;
+  device?: string;
+  timeout?: number;
+  extensions?: string | string[];
+  steps: Step[];
+  runtimeTarget?: 'ios' | 'android' | 'native';
+}
+
+// Step result
+export interface StepResult {
+  step: number;
+  action: string;
+  target?: string;
+  status: 'passed' | 'failed' | 'skipped';
+  duration: number;
+  error?: string;
+  condition?: string;
+  stepDefinition?: Step; // Include the original step definition for debugging
+}
+
+// Test result
+export interface TestResult {
+  status: 'passed' | 'failed';
+  duration: number;
+  steps: StepResult[];
+  logs?: unknown[];
+  failedAt?: number;
+  error?: string;
+}
+
+// Helper type guards
+export function isTapStep(step: Step): step is TapStep {
+  return 'tap' in step;
+}
+
+export function isInputStep(step: Step): step is InputStep {
+  return 'input' in step;
+}
+
+export function isWaitForStep(step: Step): step is WaitForStep {
+  return 'waitFor' in step && (step as any).waitFor !== undefined;
+}
+
+export function isAssertStep(step: Step): step is AssertStep {
+  return 'assert' in step;
+}
+
+export function isScrollStep(step: Step): step is ScrollStep {
+  return 'scroll' in step;
+}
+
+export function isSwipeStep(step: Step): step is SwipeStep {
+  return 'swipe' in step;
+}
+
+export function isLongPressStep(step: Step): step is LongPressStep {
+  return 'longPress' in step;
+}
+
+export function isSleepStep(step: Step): step is SleepStep {
+  return 'sleep' in step;
+}
+
+export function isLogStep(step: Step): step is LogStep {
+  return 'log' in step;
+}
+
+export function isPhaseStep(step: Step): step is PhaseStep {
+  return 'phase' in step;
+}
+
+export function isCustomStep(step: Step): step is CustomStep {
+  return 'custom' in step;
+}
+
+export function isLaunchStep(step: Step): step is LaunchStep {
+  return 'launch' in step;
+}
+
+export function isStopStep(step: Step): step is StopStep {
+  return 'stop' in step;
+}
+
+export function isSetupStep(step: Step): step is SetupStep {
+  return 'setup' in step;
+}
+
+export function isBuildStep(step: Step): step is BuildStep {
+  return 'build' in step;
+}
+
+export function isAgentLinkStep(step: Step): step is AgentLinkStep {
+  return 'agentLink' in step;
+}
+
+export function isPairStep(step: Step): step is PairStep {
+  return 'pair' in step;
+}
+
+// Get action name from step
+export function getStepAction(step: Step): string {
+  if (isTapStep(step)) return 'tap';
+  if (isInputStep(step)) return 'input';
+  if (isWaitForStep(step)) return 'waitFor';
+  if (isAssertStep(step)) return 'assert';
+  if (isScrollStep(step)) return 'scroll';
+  if (isSwipeStep(step)) return 'swipe';
+  if (isLongPressStep(step)) return 'longPress';
+  if (isSleepStep(step)) return 'sleep';
+  if (isLogStep(step)) return 'log';
+  if (isPhaseStep(step)) return 'phase';
+  if (isLaunchStep(step)) return 'launch';
+  if (isStopStep(step)) return 'stop';
+  if (isSetupStep(step)) return 'setup';
+  if (isBuildStep(step)) return 'build';
+  if (isAgentLinkStep(step)) return 'agentLink';
+  if (isPairStep(step)) return 'pair';
+  if (isCustomStep(step)) return 'custom';
+  return 'unknown';
+}
+
+// Get target from step
+export function getStepTarget(step: Step): string | undefined {
+  if (isTapStep(step)) return step.tap;
+  if (isInputStep(step)) return step.input;
+  if (isWaitForStep(step)) return step.waitFor;
+  if (isScrollStep(step)) return step.scroll;
+  if (isSwipeStep(step)) return step.swipe;
+  if (isLongPressStep(step)) return step.longPress;
+  if (isLaunchStep(step)) return step.launch;
+  if (isStopStep(step)) return step.stop;
+  if (isSetupStep(step)) return step.setup;
+  if (isBuildStep(step)) return step.build;
+  if (isAgentLinkStep(step)) return step.agentLink;
+  if (isPairStep(step)) return step.pair;
+  if (isCustomStep(step)) return step.custom;
+  return undefined;
+}
diff --git a/packages/swift b/packages/swift
index 43a9ea7..30432c9 160000
--- a/packages/swift
+++ b/packages/swift
@@ -1 +1 @@
-Subproject commit 43a9ea7996003a178afc086759bfa5dbbd127c83
+Subproject commit 30432c953d3bd770588237f80a03b3645b49e277
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index ebb129e..6abefbb 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -197,6 +197,9 @@ importers:
       glob:
         specifier: ^10.5.0
         version: 10.5.0
+      yaml:
+        specifier: ^2.3.4
+        version: 2.8.1
       yargs:
         specifier: ^17.7.2
         version: 17.7.2
@@ -253,6 +256,18 @@ importers:
 
   packages/core:
     devDependencies:
+      '@types/jest':
+        specifier: ^29.5.14
+        version: 29.5.14
+      '@types/node':
+        specifier: ^22.10.2
+        version: 22.18.13
+      jest:
+        specifier: ^29.7.0
+        version: 29.7.0(@types/node@22.18.13)
+      ts-jest:
+        specifier: ^29.2.5
+        version: 29.4.5(@babel/core@7.28.4)(@jest/transform@30.2.0)(@jest/types@30.2.0)(babel-jest@30.2.0(@babel/core@7.28.4))(jest-util@30.2.0)(jest@29.7.0(@types/node@22.18.13))(typescript@5.9.3)
       typescript:
         specifier: ^5.6.0
         version: 5.9.3
@@ -357,7 +372,7 @@ importers:
         version: 7.27.1(@babel/core@7.28.4)
       '@testing-library/react-native':
         specifier: ^13.3.3
-        version: 13.3.3(jest@30.2.0(@types/node@24.8.1))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react-test-renderer@19.2.0(react@19.2.0))(react@19.2.0)
+        version: 13.3.3(jest@30.2.0(@types/node@22.18.13))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react-test-renderer@19.2.0(react@19.2.0))(react@19.2.0)
       '@types/jest':
         specifier: ^30.0.0
         version: 30.0.0
@@ -369,7 +384,7 @@ importers:
         version: 30.2.0(@babel/core@7.28.4)
       jest:
         specifier: ^30.2.0
-        version: 30.2.0(@types/node@24.8.1)
+        version: 30.2.0(@types/node@22.18.13)
       metro-react-native-babel-preset:
         specifier: ^0.77.0
         version: 0.77.0(@babel/core@7.28.4)
@@ -378,7 +393,7 @@ importers:
         version: 19.2.0(react@19.2.0)
       ts-jest:
         specifier: ^29.4.5
-        version: 29.4.5(@babel/core@7.28.4)(@jest/transform@30.2.0)(@jest/types@30.2.0)(babel-jest@30.2.0(@babel/core@7.28.4))(jest-util@30.2.0)(jest@30.2.0(@types/node@24.8.1))(typescript@5.9.3)
+        version: 29.4.5(@babel/core@7.28.4)(@jest/transform@30.2.0)(@jest/types@30.2.0)(babel-jest@30.2.0(@babel/core@7.28.4))(jest-util@30.2.0)(jest@30.2.0(@types/node@22.18.13))(typescript@5.9.3)
 
   packages/server:
     dependencies:
@@ -5643,6 +5658,7 @@ packages:
   tar@7.5.2:
     resolution: {integrity: sha512-7NyxrTE4Anh8km8iEy7o0QYPs+0JKBTj5ZaqHg6B39erLg0qYXN3BijtShwbsNSvQ+LN75+KV+C4QR/f6Gwnpg==}
     engines: {node: '>=18'}
+    deprecated: Old versions of tar are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exhorbitant rates) by contacting i@izs.me
 
   temp-dir@2.0.0:
     resolution: {integrity: sha512-aoBAniQmmwtcKp/7BzsH8Cxzv8OL736p7v1ihGb5e9DJ9kTwGWHrQrVB5+lfVDzfGrdRzXch+ig7LHaY1JTOrg==}
@@ -7096,7 +7112,7 @@ snapshots:
       wrap-ansi: 7.0.0
       ws: 8.18.3
     optionalDependencies:
-      expo-router: 6.0.12(74b360690400157ff5dafb0887cbdf4a)
+      expo-router: 6.0.12(a390687b8741b3355d58463ddc276326)
       react-native: 0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0)
     transitivePeerDependencies:
       - '@modelcontextprotocol/sdk'
@@ -7421,7 +7437,7 @@ snapshots:
   '@jest/console@29.7.0':
     dependencies:
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       jest-message-util: 29.7.0
       jest-util: 29.7.0
@@ -7430,7 +7446,7 @@ snapshots:
   '@jest/console@30.2.0':
     dependencies:
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       jest-message-util: 30.2.0
       jest-util: 30.2.0
@@ -7443,14 +7459,14 @@ snapshots:
       '@jest/test-result': 29.7.0
       '@jest/transform': 29.7.0
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       ansi-escapes: 4.3.2
       chalk: 4.1.2
       ci-info: 3.9.0
       exit: 0.1.2
       graceful-fs: 4.2.11
       jest-changed-files: 29.7.0
-      jest-config: 29.7.0(@types/node@24.8.1)
+      jest-config: 29.7.0(@types/node@22.18.13)
       jest-haste-map: 29.7.0
       jest-message-util: 29.7.0
       jest-regex-util: 29.6.3
@@ -7479,14 +7495,14 @@ snapshots:
       '@jest/test-result': 30.2.0
       '@jest/transform': 30.2.0
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       ansi-escapes: 4.3.2
       chalk: 4.1.2
       ci-info: 4.3.1
       exit-x: 0.2.2
       graceful-fs: 4.2.11
       jest-changed-files: 30.2.0
-      jest-config: 30.2.0(@types/node@24.8.1)
+      jest-config: 30.2.0(@types/node@22.18.13)
       jest-haste-map: 30.2.0
       jest-message-util: 30.2.0
       jest-regex-util: 30.0.1
@@ -7517,14 +7533,14 @@ snapshots:
     dependencies:
       '@jest/fake-timers': 29.7.0
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-mock: 29.7.0
 
   '@jest/environment@30.2.0':
     dependencies:
       '@jest/fake-timers': 30.2.0
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-mock: 30.2.0
 
   '@jest/expect-utils@29.7.0':
@@ -7553,7 +7569,7 @@ snapshots:
     dependencies:
       '@jest/types': 29.6.3
       '@sinonjs/fake-timers': 10.3.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-message-util: 29.7.0
       jest-mock: 29.7.0
       jest-util: 29.7.0
@@ -7562,7 +7578,7 @@ snapshots:
     dependencies:
       '@jest/types': 30.2.0
       '@sinonjs/fake-timers': 13.0.5
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-message-util: 30.2.0
       jest-mock: 30.2.0
       jest-util: 30.2.0
@@ -7589,7 +7605,7 @@ snapshots:
 
   '@jest/pattern@30.0.1':
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-regex-util: 30.0.1
 
   '@jest/reporters@29.7.0':
@@ -7600,7 +7616,7 @@ snapshots:
       '@jest/transform': 29.7.0
       '@jest/types': 29.6.3
       '@jridgewell/trace-mapping': 0.3.31
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       collect-v8-coverage: 1.0.3
       exit: 0.1.2
@@ -7629,7 +7645,7 @@ snapshots:
       '@jest/transform': 30.2.0
       '@jest/types': 30.2.0
       '@jridgewell/trace-mapping': 0.3.31
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       collect-v8-coverage: 1.0.3
       exit-x: 0.2.2
@@ -7749,7 +7765,7 @@ snapshots:
       '@jest/schemas': 29.6.3
       '@types/istanbul-lib-coverage': 2.0.6
       '@types/istanbul-reports': 3.0.4
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       '@types/yargs': 17.0.33
       chalk: 4.1.2
 
@@ -7759,7 +7775,7 @@ snapshots:
       '@jest/schemas': 30.0.5
       '@types/istanbul-lib-coverage': 2.0.6
       '@types/istanbul-reports': 3.0.4
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       '@types/yargs': 17.0.33
       chalk: 4.1.2
 
@@ -8637,30 +8653,30 @@ snapshots:
     dependencies:
       '@sinonjs/commons': 3.0.1
 
-  '@testing-library/react-native@13.3.3(jest@30.2.0(@types/node@24.8.1))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.1.17)(react@19.2.0))(react-test-renderer@19.2.0(react@19.2.0))(react@19.2.0)':
+  '@testing-library/react-native@13.3.3(jest@30.2.0(@types/node@22.18.13))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react-test-renderer@19.2.0(react@19.2.0))(react@19.2.0)':
     dependencies:
       jest-matcher-utils: 30.2.0
       picocolors: 1.1.1
       pretty-format: 30.2.0
       react: 19.2.0
-      react-native: 0.81.4(@babel/core@7.28.4)(@types/react@19.1.17)(react@19.2.0)
+      react-native: 0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0)
       react-test-renderer: 19.2.0(react@19.2.0)
       redent: 3.0.0
     optionalDependencies:
-      jest: 30.2.0(@types/node@24.8.1)
-    optional: true
+      jest: 30.2.0(@types/node@22.18.13)
 
-  '@testing-library/react-native@13.3.3(jest@30.2.0(@types/node@24.8.1))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react-test-renderer@19.2.0(react@19.2.0))(react@19.2.0)':
+  '@testing-library/react-native@13.3.3(jest@30.2.0(@types/node@24.8.1))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.1.17)(react@19.2.0))(react-test-renderer@19.2.0(react@19.2.0))(react@19.2.0)':
     dependencies:
       jest-matcher-utils: 30.2.0
       picocolors: 1.1.1
       pretty-format: 30.2.0
       react: 19.2.0
-      react-native: 0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0)
+      react-native: 0.81.4(@babel/core@7.28.4)(@types/react@19.1.17)(react@19.2.0)
       react-test-renderer: 19.2.0(react@19.2.0)
       redent: 3.0.0
     optionalDependencies:
       jest: 30.2.0(@types/node@24.8.1)
+    optional: true
 
   '@tootallnate/quickjs-emscripten@0.23.0': {}
 
@@ -8693,17 +8709,17 @@ snapshots:
   '@types/body-parser@1.19.6':
     dependencies:
       '@types/connect': 3.4.38
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
 
   '@types/connect@3.4.38':
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
 
   '@types/estree@1.0.8': {}
 
   '@types/express-serve-static-core@4.19.7':
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       '@types/qs': 6.14.0
       '@types/range-parser': 1.2.7
       '@types/send': 1.2.0
@@ -8717,7 +8733,7 @@ snapshots:
 
   '@types/graceful-fs@4.1.9':
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
 
   '@types/hammerjs@2.0.46':
     optional: true
@@ -8784,16 +8800,16 @@ snapshots:
   '@types/send@0.17.5':
     dependencies:
       '@types/mime': 1.3.5
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
 
   '@types/send@1.2.0':
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
 
   '@types/serve-static@1.15.9':
     dependencies:
       '@types/http-errors': 2.0.5
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       '@types/send': 0.17.5
 
   '@types/stack-utils@2.0.3': {}
@@ -8812,7 +8828,7 @@ snapshots:
 
   '@types/yauzl@2.10.3':
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
     optional: true
 
   '@typescript-eslint/eslint-plugin@8.46.1(@typescript-eslint/parser@8.46.1(eslint@9.38.0)(typescript@5.9.3))(eslint@9.38.0)(typescript@5.9.3)':
@@ -9480,7 +9496,7 @@ snapshots:
 
   chrome-launcher@0.15.2:
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       escape-string-regexp: 4.0.0
       is-wsl: 2.2.0
       lighthouse-logger: 1.4.2
@@ -9495,7 +9511,7 @@ snapshots:
 
   chromium-edge-launcher@0.2.0:
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       escape-string-regexp: 4.0.0
       is-wsl: 2.2.0
       lighthouse-logger: 1.4.2
@@ -10335,7 +10351,7 @@ snapshots:
       - supports-color
     optional: true
 
-  expo-router@6.0.12(74b360690400157ff5dafb0887cbdf4a):
+  expo-router@6.0.12(a390687b8741b3355d58463ddc276326):
     dependencies:
       '@expo/metro-runtime': 6.1.2(expo@54.0.23)(react-dom@19.2.0(react@19.2.0))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react@19.2.0)
       '@expo/schema-utils': 0.1.7
@@ -10368,7 +10384,7 @@ snapshots:
       use-latest-callback: 0.2.6(react@19.2.0)
       vaul: 1.1.2(@types/react-dom@19.2.2(@types/react@19.2.4))(@types/react@19.2.4)(react-dom@19.2.0(react@19.2.0))(react@19.2.0)
     optionalDependencies:
-      '@testing-library/react-native': 13.3.3(jest@30.2.0(@types/node@24.8.1))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react-test-renderer@19.2.0(react@19.2.0))(react@19.2.0)
+      '@testing-library/react-native': 13.3.3(jest@30.2.0(@types/node@22.18.13))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react-test-renderer@19.2.0(react@19.2.0))(react@19.2.0)
       react-dom: 19.2.0(react@19.2.0)
       react-native-gesture-handler: 2.28.0(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react@19.2.0)
       react-native-reanimated: 4.1.3(@babel/core@7.28.4)(react-native-worklets@0.5.1(@babel/core@7.28.4)(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react@19.2.0))(react-native@0.81.4(@babel/core@7.28.4)(@types/react@19.2.4)(react@19.2.0))(react@19.2.0)
@@ -11132,7 +11148,7 @@ snapshots:
       '@jest/expect': 29.7.0
       '@jest/test-result': 29.7.0
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       co: 4.6.0
       dedent: 1.7.0
@@ -11158,7 +11174,7 @@ snapshots:
       '@jest/expect': 30.2.0
       '@jest/test-result': 30.2.0
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       co: 4.6.0
       dedent: 1.7.0
@@ -11197,6 +11213,25 @@ snapshots:
       - supports-color
       - ts-node
 
+  jest-cli@30.2.0(@types/node@22.18.13):
+    dependencies:
+      '@jest/core': 30.2.0
+      '@jest/test-result': 30.2.0
+      '@jest/types': 30.2.0
+      chalk: 4.1.2
+      exit-x: 0.2.2
+      import-local: 3.2.0
+      jest-config: 30.2.0(@types/node@22.18.13)
+      jest-util: 30.2.0
+      jest-validate: 30.2.0
+      yargs: 17.7.2
+    transitivePeerDependencies:
+      - '@types/node'
+      - babel-plugin-macros
+      - esbuild-register
+      - supports-color
+      - ts-node
+
   jest-cli@30.2.0(@types/node@24.8.1):
     dependencies:
       '@jest/core': 30.2.0
@@ -11246,32 +11281,34 @@ snapshots:
       - babel-plugin-macros
       - supports-color
 
-  jest-config@29.7.0(@types/node@24.8.1):
+  jest-config@30.2.0(@types/node@22.18.13):
     dependencies:
       '@babel/core': 7.28.4
-      '@jest/test-sequencer': 29.7.0
-      '@jest/types': 29.6.3
-      babel-jest: 29.7.0(@babel/core@7.28.4)
+      '@jest/get-type': 30.1.0
+      '@jest/pattern': 30.0.1
+      '@jest/test-sequencer': 30.2.0
+      '@jest/types': 30.2.0
+      babel-jest: 30.2.0(@babel/core@7.28.4)
       chalk: 4.1.2
-      ci-info: 3.9.0
+      ci-info: 4.3.1
       deepmerge: 4.3.1
-      glob: 7.2.3
+      glob: 10.5.0
       graceful-fs: 4.2.11
-      jest-circus: 29.7.0
-      jest-environment-node: 29.7.0
-      jest-get-type: 29.6.3
-      jest-regex-util: 29.6.3
-      jest-resolve: 29.7.0
-      jest-runner: 29.7.0
-      jest-util: 29.7.0
-      jest-validate: 29.7.0
+      jest-circus: 30.2.0
+      jest-docblock: 30.2.0
+      jest-environment-node: 30.2.0
+      jest-regex-util: 30.0.1
+      jest-resolve: 30.2.0
+      jest-runner: 30.2.0
+      jest-util: 30.2.0
+      jest-validate: 30.2.0
       micromatch: 4.0.8
       parse-json: 5.2.0
-      pretty-format: 29.7.0
+      pretty-format: 30.2.0
       slash: 3.0.0
       strip-json-comments: 3.1.1
     optionalDependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
     transitivePeerDependencies:
       - babel-plugin-macros
       - supports-color
@@ -11351,7 +11388,7 @@ snapshots:
       '@jest/environment': 29.7.0
       '@jest/fake-timers': 29.7.0
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-mock: 29.7.0
       jest-util: 29.7.0
 
@@ -11360,7 +11397,7 @@ snapshots:
       '@jest/environment': 30.2.0
       '@jest/fake-timers': 30.2.0
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-mock: 30.2.0
       jest-util: 30.2.0
       jest-validate: 30.2.0
@@ -11371,7 +11408,7 @@ snapshots:
     dependencies:
       '@jest/types': 29.6.3
       '@types/graceful-fs': 4.1.9
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       anymatch: 3.1.3
       fb-watchman: 2.0.2
       graceful-fs: 4.2.11
@@ -11386,7 +11423,7 @@ snapshots:
   jest-haste-map@30.2.0:
     dependencies:
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       anymatch: 3.1.3
       fb-watchman: 2.0.2
       graceful-fs: 4.2.11
@@ -11449,13 +11486,13 @@ snapshots:
   jest-mock@29.7.0:
     dependencies:
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-util: 29.7.0
 
   jest-mock@30.2.0:
     dependencies:
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-util: 30.2.0
 
   jest-pnp-resolver@1.2.3(jest-resolve@29.7.0):
@@ -11514,7 +11551,7 @@ snapshots:
       '@jest/test-result': 29.7.0
       '@jest/transform': 29.7.0
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       emittery: 0.13.1
       graceful-fs: 4.2.11
@@ -11540,7 +11577,7 @@ snapshots:
       '@jest/test-result': 30.2.0
       '@jest/transform': 30.2.0
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       emittery: 0.13.1
       exit-x: 0.2.2
@@ -11569,7 +11606,7 @@ snapshots:
       '@jest/test-result': 29.7.0
       '@jest/transform': 29.7.0
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       cjs-module-lexer: 1.4.3
       collect-v8-coverage: 1.0.3
@@ -11596,7 +11633,7 @@ snapshots:
       '@jest/test-result': 30.2.0
       '@jest/transform': 30.2.0
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       cjs-module-lexer: 2.1.0
       collect-v8-coverage: 1.0.3
@@ -11668,7 +11705,7 @@ snapshots:
   jest-util@29.7.0:
     dependencies:
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       ci-info: 3.9.0
       graceful-fs: 4.2.11
@@ -11677,7 +11714,7 @@ snapshots:
   jest-util@30.2.0:
     dependencies:
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       chalk: 4.1.2
       ci-info: 4.3.1
       graceful-fs: 4.2.11
@@ -11705,7 +11742,7 @@ snapshots:
     dependencies:
       '@jest/test-result': 29.7.0
       '@jest/types': 29.6.3
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       ansi-escapes: 4.3.2
       chalk: 4.1.2
       emittery: 0.13.1
@@ -11716,7 +11753,7 @@ snapshots:
     dependencies:
       '@jest/test-result': 30.2.0
       '@jest/types': 30.2.0
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       ansi-escapes: 4.3.2
       chalk: 4.1.2
       emittery: 0.13.1
@@ -11725,14 +11762,14 @@ snapshots:
 
   jest-worker@29.7.0:
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       jest-util: 29.7.0
       merge-stream: 2.0.0
       supports-color: 8.1.1
 
   jest-worker@30.2.0:
     dependencies:
-      '@types/node': 24.8.1
+      '@types/node': 22.18.13
       '@ungap/structured-clone': 1.3.0
       jest-util: 30.2.0
       merge-stream: 2.0.0
@@ -11750,6 +11787,19 @@ snapshots:
       - supports-color
       - ts-node
 
+  jest@30.2.0(@types/node@22.18.13):
+    dependencies:
+      '@jest/core': 30.2.0
+      '@jest/types': 30.2.0
+      import-local: 3.2.0
+      jest-cli: 30.2.0(@types/node@22.18.13)
+    transitivePeerDependencies:
+      - '@types/node'
+      - babel-plugin-macros
+      - esbuild-register
+      - supports-color
+      - ts-node
+
   jest@30.2.0(@types/node@24.8.1):
     dependencies:
       '@jest/core': 30.2.0
@@ -13769,6 +13819,26 @@ snapshots:
       babel-jest: 30.2.0(@babel/core@7.28.4)
       jest-util: 30.2.0
 
+  ts-jest@29.4.5(@babel/core@7.28.4)(@jest/transform@30.2.0)(@jest/types@30.2.0)(babel-jest@30.2.0(@babel/core@7.28.4))(jest-util@30.2.0)(jest@30.2.0(@types/node@22.18.13))(typescript@5.9.3):
+    dependencies:
+      bs-logger: 0.2.6
+      fast-json-stable-stringify: 2.1.0
+      handlebars: 4.7.8
+      jest: 30.2.0(@types/node@22.18.13)
+      json5: 2.2.3
+      lodash.memoize: 4.1.2
+      make-error: 1.3.6
+      semver: 7.7.3
+      type-fest: 4.41.0
+      typescript: 5.9.3
+      yargs-parser: 21.1.1
+    optionalDependencies:
+      '@babel/core': 7.28.4
+      '@jest/transform': 30.2.0
+      '@jest/types': 30.2.0
+      babel-jest: 30.2.0(@babel/core@7.28.4)
+      jest-util: 30.2.0
+
   ts-jest@29.4.5(@babel/core@7.28.4)(@jest/transform@30.2.0)(@jest/types@30.2.0)(babel-jest@30.2.0(@babel/core@7.28.4))(jest-util@30.2.0)(jest@30.2.0(@types/node@24.8.1))(typescript@5.9.3):
     dependencies:
       bs-logger: 0.2.6
diff --git a/tests/e2e/common/helpers.ts b/tests/e2e/common/helpers.ts
index ce414ba..df907bf 100644
--- a/tests/e2e/common/helpers.ts
+++ b/tests/e2e/common/helpers.ts
@@ -151,18 +151,23 @@ export async function publishPackages(): Promise<void> {
 
 /**
  * Escape a shell argument for safe use in shell commands
- * Wraps arguments containing spaces or special characters in single quotes
+ * Wraps arguments containing spaces or special characters appropriately for the platform
  */
 function escapeShellArg(arg: string): string {
   // If the argument doesn't contain spaces or special characters, return as-is
-  // Allow: letters, numbers, underscore, dash, dot, forward slash, colon, at sign
-  if (/^[a-zA-Z0-9_\-\.\/:\@=]+$/.test(arg)) {
+  // Allow: letters, numbers, underscore, dash, dot, forward slash, backslash, colon, at sign
+  if (/^[a-zA-Z0-9_\-\.\/\\:\@=]+$/.test(arg)) {
     return arg;
   }
 
-  // For arguments with spaces or special chars, wrap in single quotes
-  // and escape any single quotes within the argument
-  return "'" + arg.replace(/'/g, "'\\''") + "'";
+  // On Windows, use double quotes; on Unix, use single quotes
+  if (process.platform === 'win32') {
+    // Escape double quotes and backslashes for Windows
+    return '"' + arg.replace(/"/g, '\\"') + '"';
+  } else {
+    // For Unix-like systems, wrap in single quotes and escape any single quotes
+    return "'" + arg.replace(/'/g, "'\\''") + "'";
+  }
 }
 
 /**
diff --git a/tests/e2e/expo/test-app-launch-ios.ts b/tests/e2e/expo/test-app-launch-ios.ts
index 61c9e4c..ad2d931 100755
--- a/tests/e2e/expo/test-app-launch-ios.ts
+++ b/tests/e2e/expo/test-app-launch-ios.ts
@@ -12,6 +12,7 @@
 
 import { ChildProcess } from 'child_process';
 import { readFileSync, writeFileSync } from 'fs';
+import { join } from 'path';
 import {
   info,
   success,
@@ -209,8 +210,9 @@ async function main() {
     success('CLI packages installed from Verdaccio');
 
     // using --wait-log-timeout 500 to simulate deprecated usage
+    // Note: --localhost removed as it can cause "Could not connect to the server" errors on iOS simulator
     await runCommand(
-      `cd ${testConfigDir} && npx @agenteract/cli add-config ${exampleAppDir} expo-app 'npx expo start --ios --localhost' --wait-log-timeout 500`
+      `cd ${testConfigDir} && npx @agenteract/cli add-config ${exampleAppDir} expo-app 'npx expo start --ios' --scheme exp --wait-log-timeout 500`
     );
     success('Config created');
 
@@ -360,117 +362,37 @@ async function main() {
     // Basic assertion - verify app loaded
     assertContains(hierarchy, 'View', 'UI contains React Native View elements');
 
-    // Check for specific elements in hierarchy
-    const hasTestButton = hierarchy.includes('test-button');
-    const hasUsernameInput = hierarchy.includes('username-input');
-    const hasSwipeableCard = hierarchy.includes('swipeable-card');
-    const hasHorizontalScroll = hierarchy.includes('horizontal-scroll');
-
-    if (hasTestButton) {
-      success('✓ Found test-button in hierarchy');
-    } else {
-      info('⚠ test-button not found in hierarchy');
-    }
-
-    if (hasUsernameInput) {
-      success('✓ Found username-input in hierarchy');
-    } else {
-      info('⚠ username-input not found in hierarchy');
-    }
-
-    if (hasSwipeableCard) {
-      success('✓ Found swipeable-card in hierarchy');
-    } else {
-      info('⚠ swipeable-card not found in hierarchy');
-    }
-
-    if (hasHorizontalScroll) {
-      success('✓ Found horizontal-scroll in hierarchy');
-    } else {
-      info('⚠ horizontal-scroll not found in hierarchy');
-    }
+    success('Expo app connected and UI hierarchy loaded');
+
+    // 12. Run YAML test suite
+    info('Running YAML test suite...');
+    const testFilePath = join(process.cwd(), 'tests', 'e2e', 'expo', 'test-app.yaml');
+    
+    // Expo iOS always runs on simulator
+    const testResult = await runAgentCommand(
+      `cwd:${testConfigDir}`, 
+      'test', 
+      testFilePath, 
+      '--runtime-target', 
+      'ios'
+    );
 
-    success('UI hierarchy fetched successfully');
-
-    // 12. Test tap interaction
-    if (hasTestButton) {
-      info('Testing tap interaction on test-button...');
-      const tapResult = await runAgentCommand(`cwd:${testConfigDir}`, 'tap', 'expo-app', 'test-button');
-      assertContains(tapResult, 'success', 'Tap command executed successfully');
-      success('Button tap successful');
-
-      // 13. Verify tap was logged
-      await sleep(500);
-      const logsAfterTap = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'expo-app', '--since', '5');
-      assertContains(logsAfterTap, 'Simulate button pressed', 'Button press was logged');
-      success('Button tap verified in logs');
-    } else {
-      info('Skipping test-button tap test (button not in hierarchy)');
-    }
+    // Parse JSON result
+    const result = JSON.parse(testResult);
 
-    // 14. Test input interaction
-    if (hasUsernameInput) {
-      info('Testing input interaction on username-input...');
-      const inputResult = await runAgentCommand(
-        `cwd:${testConfigDir}`,
-        'input',
-        'expo-app',
-        'username-input',
-        'Hello from E2E test'
-      );
-      assertContains(inputResult, 'success', 'Input command executed successfully');
-      success('Text input successful');
-
-      // 15. Verify input was processed (Note: Expo example doesn't log input, but sets state)
-      // We can verify by fetching hierarchy and checking if the input has the value
-      await sleep(500);
-      const hierarchyAfterInput = await runAgentCommand(`cwd:${testConfigDir}`, 'hierarchy', 'expo-app');
-      assertContains(hierarchyAfterInput, 'Hello from E2E test', 'Input text appears in hierarchy');
-      success('Text input verified in hierarchy');
-    } else {
-      info('Skipping username-input test (input not in hierarchy)');
-    }
+    // Log the full result for debugging
+    info('Test Result:');
+    console.log(JSON.stringify(result, null, 2));
 
-    // 16. Test scroll interaction
-    if (hasHorizontalScroll) {
-      info('Testing scroll interaction on horizontal-scroll...');
-      const scrollResult = await runAgentCommand(
-        `cwd:${testConfigDir}`,
-        'scroll',
-        'expo-app',
-        'horizontal-scroll',
-        'right',
-        '100'
-      );
-      assertContains(scrollResult, 'success', 'Scroll command executed successfully');
-      success('Scroll successful');
-    } else {
-      info('Skipping horizontal-scroll test (scroll view not in hierarchy)');
+    // Verify test passed
+    if (result.status !== 'passed') {
+      error(`Test failed at step ${result.failedAt}: ${result.error}`);
+      throw new Error(`YAML test failed: ${result.error}`);
     }
 
-    // 17. Test swipe interaction
-    if (hasSwipeableCard) {
-      info('Testing swipe interaction on swipeable-card...');
-      const swipeResult = await runAgentCommand(
-        `cwd:${testConfigDir}`,
-        'swipe',
-        'expo-app',
-        'swipeable-card',
-        'left'
-      );
-      assertContains(swipeResult, 'success', 'Swipe command executed successfully');
-      success('Swipe successful');
-
-      // 18. Verify swipe was logged
-      await sleep(500);
-      const logsAfterSwipe = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'expo-app', '--since', '5');
-      assertContains(logsAfterSwipe, 'Agent swipe detected', 'Swipe was logged');
-      success('Swipe verified in logs');
-    } else {
-      info('Skipping swipeable-card test (card not in hierarchy)');
-    }
+    success(`✅ YAML test passed! (${result.steps.length} steps in ${result.duration}ms)`);
 
-    // 19. Get all logs to verify app is running
+    // Get all logs to verify app is running
     info('Fetching app logs...');
     const logs = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'expo-app', '--since', '20');
     info('Recent logs:');
diff --git a/tests/e2e/expo/test-app.yaml b/tests/e2e/expo/test-app.yaml
new file mode 100644
index 0000000..de86255
--- /dev/null
+++ b/tests/e2e/expo/test-app.yaml
@@ -0,0 +1,187 @@
+# Expo iOS App E2E Test
+# Tests UI hierarchy fetching, interactions, agentLink functionality, and state management
+
+project: expo-app
+timeout: 30000
+
+steps:
+  # 0. Test Deep Link Pairing (simulator)
+  - phase: "Test Deep Link Pairing"
+  - pair: simulator
+    platform: ios
+    timeout: 5000
+
+  # 1. Wait for app to be connected and ready
+  - phase: "Wait for App Connection"
+  - waitFor: test-button
+    timeout: 60000
+
+  # 2. Verify initial UI loaded correctly
+  - phase: "Verify Initial UI"
+  - assert:
+      exists: test-button
+
+  - assert:
+      exists: username-input
+
+  - assert:
+      exists: swipeable-card
+
+  - assert:
+      exists: horizontal-scroll
+
+  - assert:
+      exists: main-list
+
+  # 3. Test Tap Interaction
+  - phase: "Test Tap Interaction"
+
+  - tap: test-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Simulate button pressed"
+    timeout: 3000
+
+  # Tap multiple times to test state
+  - tap: test-button
+    wait: 500
+
+  - tap: test-button
+    wait: 500
+
+  # 4. Test Input Interaction
+  - phase: "Test Input Interaction"
+
+  - input: username-input
+    value: "Hello from E2E test"
+    
+  - sleep: 500
+
+  # Input is verified by checking hierarchy for the value
+  # (Note: Expo example doesn't log input changes)
+
+  # 5. Test AgentLink - Reset State (Example 1)
+  - phase: "AgentLink Test - Reset State"
+
+  # Give agentLink handler time to initialize (async in app)
+  - sleep: 2000
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 30000
+
+  # 6. Verify state was reset
+  - phase: "Verify State Reset"
+
+  - sleep: 1000
+
+  # State should be cleared, we can verify by setting new values
+
+  # 7. Set state again to test multiple interactions
+  - phase: "Set State Again"
+
+  - input: username-input
+    value: "SecondUser"
+
+  - sleep: 500
+
+  - tap: test-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Simulate button pressed"
+    timeout: 3000
+
+  # 8. Test Scroll Interaction
+  - phase: "Test Scroll Interaction"
+
+  - scroll: horizontal-scroll
+    direction: right
+    amount: 100
+
+  - sleep: 500
+
+  # 9. Test Swipe Interaction (if supported)
+  - phase: "Test Swipe Interaction"
+
+  - swipe: swipeable-card
+    direction: left
+
+  - sleep: 500
+
+  # 10. Test AgentLink - Reset State Again (Example 2)
+  - phase: "AgentLink Test - Second Reset"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 30000
+
+  # 11. Verify second reset worked
+  - phase: "Verify Second Reset"
+
+  - sleep: 1000
+
+  # 12. Test AgentLink - Reload Action (Example 3)
+  # This tests a different agentLink action
+  - phase: "AgentLink Test - Reload Action"
+
+  - agentLink: "agenteract://reload"
+
+  - waitFor: ""
+    logContains: "Reload requested via agent link"
+    timeout: 5000
+
+  # 13. Simulate app lifecycle via reset
+  # Note: Expo apps are managed by 'agenteract dev'
+  - phase: "Simulate App Lifecycle via AgentLink"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 30000
+
+  # 14. Verify app is still responsive after reset
+  - phase: "Verify App Responsive After Reset"
+
+  - sleep: 2000
+
+  - waitFor: test-button
+    timeout: 10000
+
+  - assert:
+      exists: test-button
+
+  - assert:
+      exists: username-input
+
+  - assert:
+      exists: main-list
+
+  # 15. Final interaction test
+  - phase: "Final Interaction Test"
+
+  - input: username-input
+    value: "FinalTest"
+
+  - sleep: 500
+
+  - tap: test-button
+
+  - waitFor: ""
+    logContains: "Simulate button pressed"
+    timeout: 3000
+
+  # 16. Final agentLink test for comprehensive coverage
+  - phase: "Final AgentLink Test"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 30000
diff --git a/tests/e2e/flutter/test-app-launch-ios.ts b/tests/e2e/flutter/test-app-launch-ios.ts
index 8cd4aac..e6fecea 100755
--- a/tests/e2e/flutter/test-app-launch-ios.ts
+++ b/tests/e2e/flutter/test-app-launch-ios.ts
@@ -12,6 +12,7 @@
 
 import { ChildProcess } from 'child_process';
 import { readFileSync, writeFileSync } from 'fs';
+import { join } from 'path';
 import {
   info,
   success,
@@ -25,7 +26,7 @@ import {
   spawnBackground,
   sleep,
   setupCleanup,
-} from '../common/helpers.js'; import { assert } from 'node:console';
+} from '../common/helpers.js';
 
 let agentServer: ChildProcess | null = null;
 let testConfigDir: string | null = null;
@@ -471,126 +472,35 @@ async function main() {
     // Basic assertions - verify app loaded correctly
     assertContains(hierarchy, 'Agenteract Flutter Demo', 'UI contains app title');
 
-    // Check for essential elements (be flexible - some might not be visible initially)
-    const hasCounterValue = hierarchy.includes('counter-value');
-    const hasTextInput = hierarchy.includes('text-input');
-    const hasIncrementButton = hierarchy.includes('increment-button');
-
-    if (hasCounterValue) {
-      success('✓ Found counter-value in hierarchy');
-    } else {
-      info('⚠ counter-value not found in hierarchy');
-    }
+    success('UI hierarchy fetched successfully');
 
-    if (hasTextInput) {
-      success('✓ Found text-input in hierarchy');
-    } else {
-      info('⚠ text-input not found in hierarchy');
-    }
+    // 14. Run YAML test suite
+    info('Running YAML test suite...');
+    const testFilePath = join(process.cwd(), 'tests', 'e2e', 'flutter', 'test-app.yaml');
+    
+    // Flutter iOS always runs on simulator
+    const testResult = await runAgentCommand(
+      `cwd:${testConfigDir}`, 
+      'test', 
+      testFilePath, 
+      '--runtime-target', 
+      'ios'
+    );
 
-    if (hasIncrementButton) {
-      success('✓ Found increment-button in hierarchy');
-    } else {
-      info('⚠ increment-button not found in hierarchy (FloatingActionButton may not be visible in initial hierarchy)');
-    }
+    // Parse JSON result
+    const result = JSON.parse(testResult);
 
-    success('UI hierarchy fetched successfully');
+    // Log the full result for debugging
+    info('Test Result:');
+    console.log(JSON.stringify(result, null, 2));
 
-    // 14. Test tap interaction
-    if (hasIncrementButton) {
-      info('Testing tap interaction on increment-button...');
-      const tapResult = await runAgentCommand(`cwd:${testConfigDir}`, 'tap', 'flutter-example', 'increment-button');
-      assertContains(tapResult, 'success', 'Tap command executed successfully');
-      success('Button tap successful');
-
-      // 15. Verify tap was logged and counter incremented
-      await sleep(500);
-      const logsAfterTap = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'flutter-example', '--since', '5');
-      assertContains(logsAfterTap, 'Counter incremented to 1', 'Counter increment was logged');
-      success('Button tap verified in logs');
-    } else {
-      info('Skipping increment-button tap test (button not in hierarchy)');
-      info('Trying alternative: tap on reset-button instead...');
-      try {
-        const tapResult = await runAgentCommand(`cwd:${testConfigDir}`, 'tap', 'flutter-example', 'reset-button');
-        assertContains(tapResult, 'success', 'Tap command executed successfully');
-        success('Reset button tap successful');
-
-        await sleep(500);
-        const logsAfterTap = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'flutter-example', '--since', '5');
-        assertContains(logsAfterTap, 'All values reset', 'Reset was logged');
-        success('Reset button tap verified in logs');
-      } catch (err) {
-        info(`Alternative tap test also failed: ${err}`);
-        info('Continuing with other tests...');
-      }
+    // Verify test passed
+    if (result.status !== 'passed') {
+      error(`Test failed at step ${result.failedAt}: ${result.error}`);
+      throw new Error(`YAML test failed: ${result.error}`);
     }
 
-    // 16. Test input interaction
-    info('Testing input interaction on text-input...');
-    const inputResult = await runAgentCommand(
-      `cwd:${testConfigDir}`,
-      'input',
-      'flutter-example',
-      'text-input',
-      'Hello from E2E test'
-    );
-    assertContains(inputResult, 'success', 'Input command executed successfully');
-    success('Text input successful');
-
-    // 17. Verify input was logged
-    await sleep(500);
-    const logsAfterInput = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'flutter-example', '--since', '5');
-    assertContains(logsAfterInput, 'Hello from E2E test', 'Input text was logged');
-    success('Text input verified in logs');
-
-    // 18. Test long press interaction
-    info('Testing long press interaction on long-press-view...');
-    const longPressResult = await runAgentCommand(
-      `cwd:${testConfigDir}`,
-      'longPress',
-      'flutter-example',
-      'long-press-view'
-    );
-    assertContains(longPressResult, 'success', 'Long press command executed successfully');
-    success('Long press successful');
-
-    // 19. Verify long press was logged
-    await sleep(500);
-    const logsAfterLongPress = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'flutter-example', '--since', '5');
-    assertContains(logsAfterLongPress, 'Long pressed', 'Long press was logged');
-    success('Long press verified in logs');
-
-    // 20. Test scroll interaction
-    info('Testing scroll interaction on horizontal-scroll...');
-    const scrollResult = await runAgentCommand(
-      `cwd:${testConfigDir}`,
-      'scroll',
-      'flutter-example',
-      'horizontal-scroll',
-      'right',
-      '100'
-    );
-    assertContains(scrollResult, 'success', 'Scroll command executed successfully');
-    success('Scroll successful');
-
-    // 21. Test swipe interaction
-    info('Testing swipe interaction on swipeable-card...');
-    const swipeResult = await runAgentCommand(
-      `cwd:${testConfigDir}`,
-      'swipe',
-      'flutter-example',
-      'swipeable-card',
-      'left'
-    );
-    assertContains(swipeResult, 'success', 'Swipe command executed successfully');
-    success('Swipe successful');
-
-    // 22. Verify swipe was logged
-    await sleep(500);
-    const logsAfterSwipe = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'flutter-example', '--since', '5');
-    assertContains(logsAfterSwipe, 'Card swiped', 'Swipe was logged');
-    success('Swipe verified in logs');
+    success(`✅ YAML test passed! (${result.steps.length} steps in ${result.duration}ms)`);
 
     // 23. Get all logs to verify app is running
     info('Fetching app logs...');
diff --git a/tests/e2e/flutter/test-app.yaml b/tests/e2e/flutter/test-app.yaml
new file mode 100644
index 0000000..7d92ea2
--- /dev/null
+++ b/tests/e2e/flutter/test-app.yaml
@@ -0,0 +1,233 @@
+# Flutter iOS App E2E Test
+# Tests UI hierarchy fetching, interactions, agentLink functionality, and app lifecycle
+
+project: flutter-example
+timeout: 30000
+
+steps:
+  # 0. Test Deep Link Pairing (simulator)
+  - phase: "Test Deep Link Pairing"
+  - pair: simulator
+    platform: ios
+    timeout: 5000
+
+  # 1. Wait for app to be connected and ready
+  - phase: "Wait for App Connection"
+  - waitFor: increment-button
+    timeout: 60000
+
+  # 2. Verify initial UI loaded correctly
+  - phase: "Verify Initial UI"
+  - assert:
+      exists: increment-button
+
+  - assert:
+      exists: text-input
+
+  - assert:
+      exists: long-press-view
+
+  - assert:
+      exists: swipeable-card
+
+  - assert:
+      exists: horizontal-scroll
+
+  # 3. Test Tap Interaction (Increment Counter)
+  - phase: "Test Tap Interaction"
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  - assert:
+      text:
+        testID: counter-value
+        equals: "1"
+
+  # Tap again to increment to 2
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 2"
+    timeout: 3000
+
+  - assert:
+      text:
+        testID: counter-value
+        equals: "2"
+
+  # 4. Test Input Interaction
+  - phase: "Test Input Interaction"
+  
+  - input: text-input
+    value: "Hello from E2E test"
+
+  - waitFor: ""
+    logContains: "Hello from E2E test"
+    timeout: 3000
+
+  # 5. Test Long Press Interaction
+  - phase: "Test Long Press"
+
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed"
+    timeout: 3000
+
+  # 6. Test AgentLink - Reset State (Example 1)
+  - phase: "AgentLink Test - Reset State"
+
+  # Give agentLink handler time to initialize (async in app)
+  - sleep: 2000
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 30000
+
+  # 7. Verify state was reset - counter should be back to 0
+  - phase: "Verify State Reset"
+
+  - sleep: 1000
+
+  - assert:
+      text:
+        testID: counter-value
+        equals: "0"
+
+  # 8. Set state again to test multiple reset cycles
+  - phase: "Set State Again"
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  - input: text-input
+    value: "Second input"
+
+  - waitFor: ""
+    logContains: "Second input"
+    timeout: 3000
+
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed"
+    timeout: 3000
+
+  # 9. Test AgentLink - Reset State Again (Example 2)
+  - phase: "AgentLink Test - Second Reset"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 30000
+
+  # 10. Verify second reset worked
+  - phase: "Verify Second Reset"
+
+  - sleep: 1000
+
+  - assert:
+      text:
+        testID: counter-value
+        equals: "0"
+
+  # 11. Test Scroll Interaction
+  - phase: "Test Scroll"
+
+  - scroll: horizontal-scroll
+    direction: right
+    amount: 100
+
+  - sleep: 500
+
+  # 12. Test Swipe Interaction
+  - phase: "Test Swipe"
+
+  - swipe: swipeable-card
+    direction: left
+
+  - waitFor: ""
+    logContains: "Card swiped"
+    timeout: 3000
+
+  # 13. Final state setup before lifecycle test
+  - phase: "Setup State Before Lifecycle Test"
+
+  - tap: increment-button
+    wait: 500
+
+  - tap: increment-button
+    wait: 500
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 3"
+    timeout: 3000
+
+  - assert:
+      text:
+        testID: counter-value
+        equals: "3"
+
+  # 14. Test App Lifecycle - Stop App
+  # Note: For Flutter, the app is managed by 'agenteract dev'
+  # We'll use agentLink to trigger a reset which simulates app state management
+  - phase: "Simulate App Lifecycle via AgentLink"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 30000
+
+  # 15. Verify app is still responsive and reached initial state
+  - phase: "Verify App Responsive After Reset"
+
+  - sleep: 2000
+
+  - waitFor: increment-button
+    timeout: 10000
+
+  - assert:
+      exists: increment-button
+
+  - assert:
+      exists: text-input
+
+  - assert:
+      text:
+        testID: counter-value
+        equals: "0"
+
+  # 16. Test final interaction to confirm app is fully functional
+  - phase: "Final Interaction Test"
+
+  - tap: increment-button
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # 17. One more agentLink test for comprehensive coverage
+  - phase: "Final AgentLink Test"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 30000
diff --git a/tests/e2e/kotlin/test-app-launch.ts b/tests/e2e/kotlin/test-app-launch.ts
index 3ce1db0..7c8bce9 100644
--- a/tests/e2e/kotlin/test-app-launch.ts
+++ b/tests/e2e/kotlin/test-app-launch.ts
@@ -41,7 +41,7 @@ async function cleanup() {
 
     if (platform === 'android') {
         try {
-            await runCommand('adb shell am force-stop io.agenteract.kmp_example', 'Stop Android App');
+            await runCommand('adb shell am force-stop io.agenteract.kmp_example');
         } catch (e) { /* ignore */ }
     }
 
@@ -102,7 +102,7 @@ async function main() {
         info(`Configuring agenteract for app at: ${exampleAppDir}`);
         // using --wait-log-timeout 500 to simulate deprecated usage
         await runCommand(
-            `cd "${testConfigDir}" && npx @agenteract/cli add-config "${exampleAppDir}" kmp-app "native" --wait-log-timeout 500`
+            `cd "${testConfigDir}" && npx @agenteract/cli add-config "${exampleAppDir}" kmp-app "native" --scheme agenteract-kmp-example --wait-log-timeout 500`
         );
 
         // 5. Start Agent Server
@@ -143,20 +143,30 @@ async function main() {
 
             // Ensure an emulator or device is running
             info('Checking for connected Android devices/emulators...');
-            await runCommand('adb devices', 'Verify ADB devices');
+            await runCommand('adb devices');
 
             // 1. Install the debug APK
             info(`Running ./gradlew installDebug in ${exampleAppDir}`);
             await runCommand(`cd "${exampleAppDir}" && ./gradlew installDebug`);
             success('✅ Android app installed successfully!');
 
-            // 2. Launch the app using adb
+            // // 1. Install the debug APK directly via ADB (more reliable than gradle)
+            // info(`Installing APK via ADB...`);
+            // const apkPath = join(exampleAppDir, 'build/outputs/apk/debug/kmp-example-debug.apk');
+            // await runCommand(`adb install -r "${apkPath}"`);
+            // success('✅ Android app installed successfully!');
+
+            // // 2. Clear app data to ensure fresh state (no old tokens)
+            // info('Clearing app data...');
+            // await runCommand('adb shell pm clear io.agenteract.kmp_example');
+
+            // 3. Launch the app using adb
             const androidAppId = 'io.agenteract.kmp_example'; // From build.gradle.kts
             const mainActivity = '.MainActivity'; // Common main activity name
 
             // ADB Reverse for AgentDebugBridge connection
             info('Setting up adb reverse port forwarding (8765 -> 8765)...');
-            await runCommand('adb reverse tcp:8765 tcp:8765', 'ADB Reverse');
+            await runCommand('adb reverse tcp:8765 tcp:8765');
 
             info(`Launching Android app: ${androidAppId}/${mainActivity}`);
             appProcess = spawnBackground(
@@ -168,91 +178,16 @@ async function main() {
             success('✅ Android app launched successfully!');
         }
 
-        // 7. Wait for Connection & Hierarchy
-        info('Waiting for app to connect and report hierarchy...');
-
-        // Helper to extract the main JSON object from agenteract CLI output, prioritizing by expected type
-        const extractFullJsonFromCliOutput = (output: string, expectedType: 'command' | 'hierarchy' | 'logs'): any => {
-            const lines = output.split('\n');
-            let bestMatch: any = null;
-
-            for (const line of lines) {
-                let jsonString = line;
-                // Remove common CLI prefixes
-                const rawMessagePrefix = 'Received raw message from "kmp-app": ';
-                const infoPrefix = 'ℹ️ Hierarchy received: ';
-                const debugPrefix = '[agenteract-dev] [DEBUG] ';
-
-                if (line.includes(rawMessagePrefix)) {
-                    jsonString = line.substring(line.indexOf(rawMessagePrefix) + rawMessagePrefix.length).trim();
-                } else if (line.includes(infoPrefix)) {
-                    jsonString = line.substring(line.indexOf(infoPrefix) + infoPrefix.length).trim();
-                } else if (line.includes(debugPrefix)) {
-                    const jsonStart = line.indexOf('{');
-                    const jsonEnd = line.lastIndexOf('}');
-                    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
-                        jsonString = line.substring(jsonStart, jsonEnd + 1).trim();
-                    } else {
-                        continue; // No JSON in this debug line
-                    }
-                }
-
-                if (jsonString.startsWith('{') && jsonString.endsWith('}')) {
-                    try {
-                        const parsedJson = JSON.parse(jsonString);
-                        // Prioritize based on expected type
-                        if (expectedType === 'command' && parsedJson.status === 'ok' && parsedJson.hierarchy === null && parsedJson.logs === null) {
-                            return parsedJson; // Exact match for a command response
-                        } else if (expectedType === 'hierarchy' && parsedJson.hierarchy !== null && parsedJson.status === 'success') {
-                            bestMatch = parsedJson; // Keep as best hierarchy match so far
-                        } else if (expectedType === 'logs' && parsedJson.logs !== null && parsedJson.status === 'success') {
-                            bestMatch = parsedJson; // Keep as best logs match so far
-                        }
-                        // If we found a perfect match for hierarchy/logs, return immediately
-                        // This prevents it from being overridden by a less specific match later
-                        if (bestMatch && (
-                            (expectedType === 'hierarchy' && bestMatch.hierarchy !== null) ||
-                            (expectedType === 'logs' && bestMatch.logs !== null)
-                        )) {
-                            return bestMatch;
-                        }
-
-                    } catch (e) {
-                        // Not valid JSON, continue
-                    }
-                }
-            }
-            return bestMatch; // Return the best match if no exact command match was found
-        };
-
-
-        const verifyInLogs = async (message: string): Promise<void> => {
-            const logsOutput = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'kmp-app', '--since', '20');
-            const logs = JSON.parse(logsOutput).logs;
-            const log = logs.find((log: any) => log.message.includes(message));
-            if (!log) throw new Error(`${message} log not found in logs: ${logsOutput}`);
-            success(`${message} verified in logs`);
-        };
-
-        let fullResponse: any = null;
-        let hierarchy: any = null;
+        // 7. Wait for app to connect
+        info('Waiting for app to connect to agent server...');
 
         await waitFor(
             async () => {
                 try {
+                    // Just check if we can get any hierarchy response
                     const rawOutput = await runAgentCommand(`cwd:${testConfigDir}`, 'hierarchy', 'kmp-app');
-                    fullResponse = extractFullJsonFromCliOutput(rawOutput, 'hierarchy'); // Pass 'hierarchy' type
-
-                    if (!fullResponse || fullResponse.status !== 'success' || !fullResponse.hierarchy) {
-                        return false;
-                    }
-                    hierarchy = fullResponse.hierarchy;
-
-                    // Check for AgentRegistry and a button with a testID
-                    const jsonString = JSON.stringify(hierarchy);
-                    return jsonString.includes('AgentRegistry') && jsonString.includes('"testID":"increment-button"');
+                    return rawOutput.includes('increment-button');
                 } catch (err) {
-                    // info(`Error in waitFor: ${err}`);
                     return false;
                 }
             },
@@ -261,132 +196,38 @@ async function main() {
             2000
         );
 
-        if (!hierarchy) {
-            throw new Error('Failed to get initial hierarchy from KMP app');
-        }
-
-        // 8. Verify initial UI loaded correctly
-        const initialHierarchyJsonString = JSON.stringify(hierarchy);
-        assertContains(initialHierarchyJsonString, '"testID":"increment-button"', 'Initial UI contains increment button');
-        assertContains(initialHierarchyJsonString, '"testID":"text-input"', 'Initial UI contains text input');
-        assertContains(initialHierarchyJsonString, '"testID":"long-press-view"', 'Initial UI contains long press view');
-        assertContains(initialHierarchyJsonString, '"testID":"swipeable-card"', 'Initial UI contains swipeable card');
-        assertContains(initialHierarchyJsonString, '"testID":"horizontal-scroll"', 'Initial UI contains horizontal scroll');
-        success('Initial UI hierarchy fetched and verified successfully');
-
-        // 9. Test Tap Interaction (Increment Counter)
-        info('Testing tap interaction on increment-button...');
-        const tapRawOutput = await runAgentCommand(`cwd:${testConfigDir}`, 'tap', 'kmp-app', 'increment-button');
-        const tapResponse = extractFullJsonFromCliOutput(tapRawOutput, 'command'); // Pass 'command' type
-        if (!tapResponse || tapResponse.status !== 'ok') {
-            throw new Error(`Tap command failed: ${tapRawOutput}`);
-        }
-        success('Button tap command sent');
-
-        await sleep(500);
-
-        // Verify counter incremented in hierarchy
-        const hierarchyAfterTapRaw = await runAgentCommand(`cwd:${testConfigDir}`, 'hierarchy', 'kmp-app');
-        const fullResponseAfterTap = extractFullJsonFromCliOutput(hierarchyAfterTapRaw, 'hierarchy'); // Pass 'hierarchy' type
-        if (!fullResponseAfterTap || fullResponseAfterTap.status !== 'success' || !fullResponseAfterTap.hierarchy) {
-            throw new Error(`Failed to get hierarchy after tap: ${hierarchyAfterTapRaw}`);
-        }
-        const hierarchyAfterTap = fullResponseAfterTap.hierarchy;
-        const hierarchyAfterTapJsonString = JSON.stringify(hierarchyAfterTap);
-
-        assertContains(hierarchyAfterTapJsonString, '"testID":"counter-value"', 'Hierarchy contains counter-value');
-        assertContains(hierarchyAfterTapJsonString, '"text":"1"', 'Counter incremented to 1 in hierarchy');
-        success('Counter increment verified in hierarchy');
-
-        await verifyInLogs('Counter incremented to 1');
-
-
-        // 10. Test Input Interaction
-        info('Testing input interaction on text-input...');
-        const inputRawOutput = await runAgentCommand(`cwd:${testConfigDir}`, 'input', 'kmp-app', 'text-input', 'Hello KMP');
-        const inputResponse = extractFullJsonFromCliOutput(inputRawOutput, 'command'); // Pass 'command' type
-        if (!inputResponse || inputResponse.status !== 'ok') {
-            throw new Error(`Input command failed: ${inputRawOutput}`);
-        }
-        success('Input command sent');
-
-        await sleep(500);
-
-        const hierarchyAfterInputRaw = await runAgentCommand(`cwd:${testConfigDir}`, 'hierarchy', 'kmp-app');
-        const fullResponseAfterInput = extractFullJsonFromCliOutput(hierarchyAfterInputRaw, 'hierarchy'); // Pass 'hierarchy' type
-        if (!fullResponseAfterInput || fullResponseAfterInput.status !== 'success' || !fullResponseAfterInput.hierarchy) {
-            throw new Error(`Failed to get hierarchy after input: ${hierarchyAfterInputRaw}`);
-        }
-        const hierarchyAfterInput = fullResponseAfterInput.hierarchy;
-        const hierarchyAfterInputJsonString = JSON.stringify(hierarchyAfterInput);
-
-        assertContains(hierarchyAfterInputJsonString, '"testID":"input-display-text"', 'Hierarchy contains input-display-text');
-        assertContains(hierarchyAfterInputJsonString, '"text":"Input value: Hello KMP"', 'UI updated with input text in hierarchy');
-
-        await verifyInLogs('Input changed: Hello KMP');
-
-
-        // 11. Test Long Press Interaction
-        info('Testing long press interaction on long-press-view...');
-        const longPressRawOutput = await runAgentCommand(`cwd:${testConfigDir}`, 'longPress', 'kmp-app', 'long-press-view');
-        const longPressResponse = extractFullJsonFromCliOutput(longPressRawOutput, 'command'); // Pass 'command' type
-        if (!longPressResponse || longPressResponse.status !== 'ok') {
-            throw new Error(`Long press command failed: ${longPressRawOutput}`);
-        }
-        success('Long press command sent');
-
-        await sleep(500);
-        const hierarchyAfterLongPressRaw = await runAgentCommand(`cwd:${testConfigDir}`, 'hierarchy', 'kmp-app');
-        const fullResponseAfterLongPress = extractFullJsonFromCliOutput(hierarchyAfterLongPressRaw, 'hierarchy'); // Pass 'hierarchy' type
-        if (!fullResponseAfterLongPress || fullResponseAfterLongPress.status !== 'success' || !fullResponseAfterLongPress.hierarchy) {
-            throw new Error(`Failed to get hierarchy after long press: ${hierarchyAfterLongPressRaw}`);
-        }
-        const hierarchyAfterLongPress = fullResponseAfterLongPress.hierarchy;
-        const hierarchyAfterLongPressJsonString = JSON.stringify(hierarchyAfterLongPress);
-
-        assertContains(hierarchyAfterLongPressJsonString, '"testID":"long-press-count-text"', 'Hierarchy contains long-press-count-text');
-        assertContains(hierarchyAfterLongPressJsonString, '"text":"Long press count: 1"', 'UI updated after long press in hierarchy');
-
-        await verifyInLogs('Long pressed! Count: 1');
-
-        // 12. Test Swipe Interaction
-        info('Testing swipe interaction on swipeable-card...');
-        const swipeRawOutput = await runAgentCommand(`cwd:${testConfigDir}`, 'swipe', 'kmp-app', 'swipeable-card', 'left');
-        const swipeResponse = extractFullJsonFromCliOutput(swipeRawOutput, 'command'); // Pass 'command' type
-        if (!swipeResponse || swipeResponse.status !== 'ok') {
-            throw new Error(`Swipe command failed: ${swipeRawOutput}`);
-        }
-        success('Swipe command sent');
-
-        await sleep(500);
-        await verifyInLogs('Card swiped left');
+        success('KMP app connected and initial hierarchy loaded');
+
+        // 8. Run YAML test suite
+        info('Running YAML test suite...');
+        const testFilePath = join(process.cwd(), 'tests', 'e2e', 'kotlin', 'test-app.yaml');
+        
+        // Determine runtime target based on platform
+        const runtimeTarget = platform === 'desktop' ? 'native' : 'android';
+        info(`Runtime target: ${runtimeTarget}`);
+        
+        const testResult = await runAgentCommand(
+            `cwd:${testConfigDir}`, 
+            'test', 
+            testFilePath, 
+            '--runtime-target', 
+            runtimeTarget
+        );
 
-        // 13. Test Scroll Interaction
-        info('Testing scroll interaction on horizontal-scroll...');
-        const scrollRawOutput = await runAgentCommand(`cwd:${testConfigDir}`, 'scroll', 'kmp-app', 'horizontal-scroll', 'right', '100');
-        const scrollResponse = extractFullJsonFromCliOutput(scrollRawOutput, 'command'); // Pass 'command' type
-        if (!scrollResponse || scrollResponse.status !== 'ok') {
-            throw new Error(`Scroll command failed: ${scrollRawOutput}`);
-        }
-        success('Scroll command sent');
+        // Parse JSON result
+        const result = JSON.parse(testResult);
 
-        await sleep(500);
-        await verifyInLogs('Scrolled right by 100.0');
+        // Log the full result for debugging
+        info('Test Result:');
+        console.log(JSON.stringify(result, null, 2));
 
-        // 14. Reset All
-        info('Testing reset button...');
-        const resetRawOutput = await runAgentCommand(`cwd:${testConfigDir}`, 'tap', 'kmp-app', 'reset-button');
-        const resetResponse = extractFullJsonFromCliOutput(resetRawOutput, 'command'); // Pass 'command' type
-        if (!resetResponse || resetResponse.status !== 'ok') {
-            throw new Error(`Reset command failed: ${resetRawOutput}`);
+        // Verify test passed
+        if (result.status !== 'passed') {
+            error(`Test failed at step ${result.failedAt}: ${result.error}`);
+            throw new Error(`YAML test failed: ${result.error}`);
         }
-        success('Reset command sent');
-
-        await sleep(500);
-
-        await verifyInLogs('All values reset');
 
-        success('✅ Kotlin Full Suite E2E Test Passed!');
+        success(`✅ YAML test passed! (${result.steps.length} steps in ${result.duration}ms)`);
 
     } catch (err) {
         error(`Test failed: ${err}`);
diff --git a/tests/e2e/kotlin/test-app.yaml b/tests/e2e/kotlin/test-app.yaml
new file mode 100644
index 0000000..da5a5d5
--- /dev/null
+++ b/tests/e2e/kotlin/test-app.yaml
@@ -0,0 +1,355 @@
+# Kotlin KMP App E2E Test
+# Tests UI hierarchy fetching, various interactions, agentLink functionality, and state management
+# Works on both Android and Desktop platforms
+
+project: kmp-app
+timeout: 30000
+
+steps:
+  # 0. Test Deep Link Pairing (emulator)
+  - phase: "Test Deep Link Pairing"
+  - pair: emulator
+    platform: android
+    timeout: 5000
+
+  # 1. Wait for app to be connected and ready
+  - phase: "Wait for App Connection"
+  - waitFor: increment-button
+    timeout: 60000
+
+  # 2. Verify initial UI loaded correctly
+  - phase: "Verify Initial UI"
+  - assert:
+      exists: increment-button
+
+  - assert:
+      exists: text-input
+
+  - assert:
+      exists: long-press-view
+
+  - assert:
+      exists: swipeable-card
+
+  - assert:
+      exists: horizontal-scroll
+
+  # 3. Test Tap Interaction (Increment Counter)
+  - phase: "Test Tap Interaction"
+
+  - tap: increment-button
+    wait: 500
+
+  # Verify counter incremented to 1
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # Tap multiple times
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 2"
+    timeout: 3000
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 3"
+    timeout: 3000
+
+  # 4. Test Input Interaction
+  - phase: "Test Input Interaction"
+  
+  - input: text-input
+    value: "Hello KMP"
+
+  - waitFor: ""
+    logContains: "Input changed: Hello KMP"
+    timeout: 3000
+
+  # Change input again
+  - input: text-input
+    value: "Testing input changes"
+
+  - waitFor: ""
+    logContains: "Input changed: Testing input changes"
+    timeout: 3000
+
+  # 5. Test Long Press Interaction
+  - phase: "Test Long Press Interaction"
+
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed! Count: 1"
+    timeout: 3000
+
+  # Long press again
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed! Count: 2"
+    timeout: 3000
+
+  # 6. Test AgentLink - Reset State (Example 1)
+  - phase: "AgentLink Test - Reset State"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+
+  # 7. Verify state was reset
+  - phase: "Verify State Reset"
+
+  - sleep: 1000
+
+  # After reset, counter should be back to 0
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # 8. Set state again for multiple interaction test
+  - phase: "Set State Again"
+
+  - tap: increment-button
+    wait: 500
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 3"
+    timeout: 3000
+
+  - input: text-input
+    value: "Second input"
+
+  - waitFor: ""
+    logContains: "Input changed: Second input"
+    timeout: 3000
+
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed! Count: 1"
+    timeout: 3000
+
+  # 9. Test Swipe Interaction
+  - phase: "Test Swipe Interaction"
+
+  - swipe: swipeable-card
+    direction: left
+
+  - waitFor: ""
+    logContains: "Card swiped left"
+    timeout: 3000
+
+  # Swipe in different direction
+  - swipe: swipeable-card
+    direction: right
+
+  - waitFor: ""
+    logContains: "Card swiped right"
+    timeout: 3000
+
+  # 10. Test Scroll Interaction
+  - phase: "Test Scroll Interaction"
+
+  - scroll: horizontal-scroll
+    direction: right
+    amount: 100
+
+  - waitFor: ""
+    logContains: "Scrolled right by 100.0"
+    timeout: 3000
+
+  # Scroll in opposite direction
+  - scroll: horizontal-scroll
+    direction: left
+    amount: 50
+
+  - waitFor: ""
+    logContains: "Scrolled left by 50.0"
+    timeout: 3000
+
+  # 11. Test AgentLink - Reset State Again (Example 2)
+  - phase: "AgentLink Test - Second Reset"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+
+  # 12. Verify second reset worked
+  - phase: "Verify Second Reset"
+
+  - sleep: 1000
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # 13. Build up state for reset button test
+  - phase: "Build State for Reset Button"
+
+  - tap: increment-button
+    wait: 500
+
+  - tap: increment-button
+    wait: 500
+
+  - input: text-input
+    value: "Before reset button"
+
+  - waitFor: ""
+    logContains: "Input changed: Before reset button"
+    timeout: 3000
+
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed! Count: 1"
+    timeout: 3000
+
+  # 14. Test Manual Reset Button
+  - phase: "Test Manual Reset Button"
+
+  - tap: reset-button
+
+  - waitFor: ""
+    logContains: "All values reset"
+    timeout: 3000
+
+  # 15. Verify manual reset worked
+  - phase: "Verify Manual Reset"
+
+  - sleep: 1000
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # 16. Simulate app lifecycle via agentLink
+  - phase: "Simulate App Lifecycle via AgentLink"
+
+  # Build up some state first
+  - tap: increment-button
+    wait: 500
+
+  - tap: increment-button
+    wait: 500
+
+  - tap: increment-button
+    wait: 500
+
+  - input: text-input
+    value: "Before lifecycle test"
+
+  - sleep: 500
+
+  # Use agentLink to reset (simulates app state management)
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+
+  # 17. Verify app is still responsive after reset
+  - phase: "Verify App Responsive After Reset"
+
+  - sleep: 2000
+
+  - waitFor: increment-button
+    timeout: 10000
+
+  - assert:
+      exists: increment-button
+
+  - assert:
+      exists: text-input
+
+  - assert:
+      exists: reset-button
+
+  # 18. Final comprehensive interaction test
+  - phase: "Final Comprehensive Test"
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  - input: text-input
+    value: "Final test"
+
+  - waitFor: ""
+    logContains: "Input changed: Final test"
+    timeout: 3000
+
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed! Count: 1"
+    timeout: 3000
+
+  - swipe: swipeable-card
+    direction: left
+
+  - waitFor: ""
+    logContains: "Card swiped left"
+    timeout: 3000
+
+  - scroll: horizontal-scroll
+    direction: right
+    amount: 75
+
+  - waitFor: ""
+    logContains: "Scrolled right by 75.0"
+    timeout: 3000
+
+  # 19. Final agentLink test for comprehensive coverage
+  - phase: "Final AgentLink Test"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+
+  # 20. Final state verification
+  - phase: "Final State Verification"
+
+  - sleep: 1000
+
+  - waitFor: increment-button
+    timeout: 5000
+
+  - assert:
+      exists: increment-button
+
+  - assert:
+      exists: text-input
+
+  - tap: increment-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
diff --git a/tests/e2e/swiftui/test-app-launch-ios.ts b/tests/e2e/swiftui/test-app-launch-ios.ts
index 03a5c3d..aaf47e8 100755
--- a/tests/e2e/swiftui/test-app-launch-ios.ts
+++ b/tests/e2e/swiftui/test-app-launch-ios.ts
@@ -12,6 +12,7 @@
 
 import { ChildProcess } from 'child_process';
 import { readFileSync, writeFileSync } from 'fs';
+import { join } from 'path';
 import {
   info,
   success,
@@ -222,7 +223,7 @@ async function main() {
     info('Creating agenteract config for swift-app in /tmp...');
     // using --wait-log-timeout 500 to simulate deprecated usage
     await runCommand(
-      `cd ${testConfigDir} && npx @agenteract/cli add-config ${exampleAppDir} swift-app native --wait-log-timeout 500`
+      `cd ${testConfigDir} && npx @agenteract/cli add-config ${exampleAppDir} swift-app native --scheme agenteract-swift-example --wait-log-timeout 500`
     );
     success(`Config created in ${testConfigDir}`);
 
@@ -336,121 +337,30 @@ async function main() {
     // 13. Verify we have a valid hierarchy
     info('Verifying UI hierarchy...');
 
-    // Check for essential elements (be flexible - some might not be visible initially)
-    const hasCounterValue = hierarchy.includes('tap-count-text');
-    const hasTextInput = hierarchy.includes('text-input');
-    const hasIncrementButton = hierarchy.includes('tap-button');
-
-    if (hasCounterValue) {
-      success('✓ Found tap-count-text in hierarchy');
-    } else {
-      error('tap-count-text not found in hierarchy');
-      throw new Error('tap-count-text not found in hierarchy');
-    }
-
-    if (hasTextInput) {
-      success('✓ Found text-input in hierarchy');
-    } else {
-      error('text-input not found in hierarchy');
-      throw new Error('text-input not found in hierarchy');
-    }
-
-    if (hasIncrementButton) {
-      success('✓ Found increment-button in hierarchy');
-    } else {
-      error('increment-button not found in hierarchy (FloatingActionButton may not be visible in initial hierarchy)');
-      throw new Error('increment-button not found in hierarchy');
-    }
+    // Basic check - just verify we got a hierarchy
+    assertContains(hierarchy, 'tap-button', 'UI contains tap button');
 
     success('UI hierarchy fetched successfully');
 
-    // 14. Test tap interaction
-    if (hasIncrementButton) {
-      info('Testing tap interaction on increment-button...');
-      const tapResult = await runAgentCommand(`cwd:${testConfigDir}`, 'tap', 'swift-app', 'tap-button');
-      // note that this success doesn't mean the tap was successful, we need to check the console logs
-      // assertContains(tapResult, 'success', 'Tap command executed successfully');
-      assertContains(tapResult, 'Counter incremented to 1', 'Counter increment was logged');
-      success('Button tap verified in logs');
-    }
+    // 14. Run YAML test suite
+    info('Running YAML test suite...');
+    const testFilePath = join(process.cwd(), 'tests', 'e2e', 'swiftui', 'test-app.yaml');
+    const testResult = await runAgentCommand(`cwd:${testConfigDir}`, 'test', testFilePath, '--runtime-target', 'ios');
 
-    // 16. Test input interaction
-    info('Testing input interaction on text-input...');
-    const inputResult = await runAgentCommand(
-      `cwd:${testConfigDir}`,
-      'input',
-      'swift-app',
-      'text-input',
-      'Hello from E2E test'
-    );
-    assertContains(inputResult, 'success', 'Input command executed successfully');
-    success('Text input successful');
-
-    // 17. Verify input was logged
-    await sleep(500);
-    const logsAfterInput = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'swift-app', '--since', '5');
-    assertContains(logsAfterInput, 'Hello from E2E test', 'Input text was logged');
-    success('Text input verified in logs');
-
-    // 18. Test long press interaction
-    info('Testing long press interaction on long-press-view...');
-    const longPressResult = await runAgentCommand(
-      `cwd:${testConfigDir}`,
-      'longPress',
-      'swift-app',
-      'long-press-view'
-    );
-    assertContains(longPressResult, 'success', 'Long press command executed successfully');
-    success('Long press successful');
-
-    // 19. Verify long press was logged
-    await sleep(500);
-    const logsAfterLongPress = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'swift-app', '--since', '5');
-    assertContains(logsAfterLongPress, 'Long pressed', 'Long press was logged');
-    success('Long press verified in logs');
-
-    // 20. Test scroll interaction
-    info('Testing scroll interaction on horizontal-scroll...');
-    const scrollResult = await runAgentCommand(
-      `cwd:${testConfigDir}`,
-      'scroll',
-      'swift-app',
-      'horizontal-scroll',
-      'right',
-      '100'
-    );
-    assertContains(scrollResult, 'success', 'Scroll command executed successfully');
-    success('Scroll successful');
-
-    // 21. Test swipe interaction
-    info('Testing swipe interaction on swipeable-card...');
-    const swipeResult = await runAgentCommand(
-      `cwd:${testConfigDir}`,
-      'swipe',
-      'swift-app',
-      'swipeable-card',
-      'left'
-    );
-    assertContains(swipeResult, 'success', 'Swipe command executed successfully');
-    success('Swipe successful');
+    // Parse JSON result
+    const result = JSON.parse(testResult);
 
-    // 22. Verify swipe was logged
-    await sleep(500);
-    const logsAfterSwipe = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'swift-app', '--since', '5');
-    assertContains(logsAfterSwipe, 'Card swiped', 'Swipe was logged');
-    success('Swipe verified in logs');
+    // Log the full result for debugging
+    info('Test Result:');
+    console.log(JSON.stringify(result, null, 2));
 
-    // 23. Check dev logs
-    info('Checking Swift-App dev server logs...');
-    try {
-      const devLogs = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'swift-app', '--since', '30');
-      info('Swift-App dev logs:');
-      console.log(devLogs);
-    } catch (err) {
-      error(`Failed to get dev logs: ${err}`);
+    // Verify test passed
+    if (result.status !== 'passed') {
+      error(`Test failed at step ${result.failedAt}: ${result.error}`);
+      throw new Error(`YAML test failed: ${result.error}`);
     }
 
-    success('✅ All tests passed!');
+    success(`✅ YAML test passed! (${result.steps.length} steps in ${result.duration}ms)`);
 
   } catch (err) {
     error(`Test failed: ${err}`);
diff --git a/tests/e2e/swiftui/test-app.yaml b/tests/e2e/swiftui/test-app.yaml
new file mode 100644
index 0000000..6f1d37a
--- /dev/null
+++ b/tests/e2e/swiftui/test-app.yaml
@@ -0,0 +1,281 @@
+# Swift iOS App E2E Test
+# Tests UI hierarchy fetching, interactions, agentLink functionality, and state management
+
+project: swift-app
+timeout: 30000
+
+steps:
+  # 0. Test Deep Link Pairing (simulator)
+  - phase: "Test Deep Link Pairing"
+  - pair: simulator
+    platform: ios
+    timeout: 5000
+
+  # 1. Wait for app to be connected and ready
+  - phase: "Wait for App Connection"
+  - waitFor: tap-button
+    timeout: 60000
+
+  # 2. Verify initial UI loaded correctly
+  - phase: "Verify Initial UI"
+  - assert:
+      exists: tap-button
+
+  - assert:
+      exists: text-input
+
+  - assert:
+      exists: long-press-view
+
+  - assert:
+      exists: swipeable-card
+
+  - assert:
+      exists: horizontal-scroll
+
+  - assert:
+      exists: main-list
+
+  - assert:
+      exists: reset-button
+
+  # 3. Test Tap Interaction
+  - phase: "Test Tap Interaction"
+
+  - tap: tap-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # Tap multiple times
+  - tap: tap-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 2"
+    timeout: 3000
+
+  - tap: tap-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 3"
+    timeout: 3000
+
+  # 4. Test Input Interaction
+  - phase: "Test Input Interaction"
+  
+  - input: text-input
+    value: "Hello from E2E test"
+
+  - waitFor: ""
+    logContains: "Input text changed to Hello from E2E test"
+    timeout: 3000
+
+  # 5. Test Long Press Interaction
+  - phase: "Test Long Press Interaction"
+
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed! Count: 1"
+    timeout: 3000
+
+  # 6. Test AgentLink - Reset State (Example 1)
+  - phase: "AgentLink Test - Reset State"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+
+  # 7. Verify state was reset
+  - phase: "Verify State Reset"
+
+  - sleep: 1000
+
+  # After reset, tap counter should be back to 0
+  - tap: tap-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # 8. Set state again for multiple reset test
+  - phase: "Set State Again"
+
+  - tap: tap-button
+    wait: 500
+
+  - tap: tap-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 3"
+    timeout: 3000
+
+  - input: text-input
+    value: "Second input test"
+
+  - waitFor: ""
+    logContains: "Input text changed to Second input test"
+    timeout: 3000
+
+  - longPress: long-press-view
+
+  - waitFor: ""
+    logContains: "Long pressed! Count: 1"
+    timeout: 3000
+
+  # 9. Test Swipe Interaction
+  - phase: "Test Swipe Interaction"
+
+  - swipe: swipeable-card
+    direction: left
+
+  - waitFor: ""
+    logContains: "Card swiped"
+    timeout: 3000
+
+  # 10. Test Scroll Interaction
+  - phase: "Test Scroll Interaction"
+
+  - scroll: horizontal-scroll
+    direction: right
+    amount: 100
+
+  - sleep: 500
+
+  # 11. Test AgentLink - Reset State Again (Example 2)
+  - phase: "AgentLink Test - Second Reset"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+
+  # 12. Verify second reset worked
+  - phase: "Verify Second Reset"
+
+  - sleep: 1000
+
+  - tap: tap-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # 13. Test Reset Button (manual reset)
+  - phase: "Test Manual Reset Button"
+
+  - tap: tap-button
+    wait: 500
+
+  - tap: tap-button
+    wait: 500
+
+  # Counter should be at 3 now
+  - waitFor: ""
+    logContains: "Counter incremented to 3"
+    timeout: 3000
+
+  - tap: reset-button
+
+  - waitFor: ""
+    logContains: "All values reset"
+    timeout: 3000
+
+  # 14. Verify manual reset worked
+  - phase: "Verify Manual Reset"
+
+  - sleep: 1000
+
+  - tap: tap-button
+    wait: 500
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  # 15. Simulate app lifecycle via agentLink reset
+  - phase: "Simulate App Lifecycle via AgentLink"
+
+  - tap: tap-button
+    wait: 500
+
+  - tap: tap-button
+    wait: 500
+
+  - input: text-input
+    value: "Before lifecycle test"
+
+  - sleep: 500
+
+  # Use agentLink to reset (simulates app restart)
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+
+  # 16. Verify app is still responsive after reset
+  - phase: "Verify App Responsive After Reset"
+
+  - sleep: 2000
+
+  - waitFor: tap-button
+    timeout: 10000
+
+  - assert:
+      exists: tap-button
+
+  - assert:
+      exists: text-input
+
+  - assert:
+      exists: reset-button
+
+  # 17. Final interaction test
+  - phase: "Final Interaction Test"
+
+  - tap: tap-button
+
+  - waitFor: ""
+    logContains: "Counter incremented to 1"
+    timeout: 3000
+
+  - input: text-input
+    value: "Final test input"
+
+  - waitFor: ""
+    logContains: "Input text changed to Final test input"
+    timeout: 3000
+
+  # 18. Final agentLink test for comprehensive coverage
+  - phase: "Final AgentLink Test"
+
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 3000
+
+  - sleep: 1000
+
+  # 19. Final state verification
+  - phase: "Final State Verification"
+
+  - waitFor: tap-button
+    timeout: 5000
+
+  - assert:
+      exists: tap-button
+
+  - assert:
+      exists: text-input
diff --git a/tests/e2e/vite/test-app-launch.ts b/tests/e2e/vite/test-app-launch.ts
index 5b3b2f8..432f293 100644
--- a/tests/e2e/vite/test-app-launch.ts
+++ b/tests/e2e/vite/test-app-launch.ts
@@ -9,13 +9,10 @@
  * 4. UI hierarchy can be fetched
  */
 
-import { ChildProcess, exec as execCallback } from 'child_process';
-import { promisify } from 'util';
-import puppeteer, { Browser } from 'puppeteer';
+import { ChildProcess } from 'child_process';
 import { readFileSync, writeFileSync, existsSync, cpSync, rmSync, mkdirSync } from 'fs';
 import { join } from 'path';
 
-const exec = promisify(execCallback);
 import {
   info,
   success,
@@ -25,31 +22,23 @@ import {
   publishPackages,
   runCommand,
   runAgentCommand,
-  assertContains,
   spawnBackground,
   killProcess,
-  waitFor,
   sleep,
   setupCleanup,
   getTmpDir,
 } from '../common/helpers.js';
 
 let agentServer: ChildProcess | null = null;
-let browser: Browser | null = null;
 let testConfigDir: string | null = null;
 let exampleAppDir: string | null = null;
 
 async function cleanup() {
   info('Cleaning up...');
 
-  if (browser) {
-    try {
-      await browser.close();
-      info('Browser closed');
-    } catch (err) {
-      // Ignore browser cleanup errors
-    }
-  }
+  // Browser is now managed by YAML test (launch/stop steps)
+  // The YAML test should have called stopApp which closes the browser,
+  // but if cleanup is called due to error, we need a fallback
 
   if (agentServer) {
     await killProcess(agentServer, 'Agenteract dev');
@@ -92,6 +81,15 @@ async function main() {
       } catch (err) {
         // Ignore cleanup errors
       }
+
+      // Also clean up any orphaned puppeteer processes from previous failed test runs
+      info('Cleaning up any orphaned puppeteer/Chrome processes...');
+      try {
+        await runCommand('pkill -f "puppeteer_dev_chrome_profile" 2>/dev/null || true');
+        await sleep(1000);
+      } catch (err) {
+        // Ignore cleanup errors
+      }
     }
 
     // 2. Start Verdaccio
@@ -217,7 +215,8 @@ export default defineConfig({
     mkdirSync(testConfigDir, { recursive: true });
     await runCommand(`cd "${testConfigDir}" && npm init -y`);
     // install packages so latest are used with npx
-    await runCommand(`cd "${testConfigDir}" && npm install @agenteract/cli @agenteract/agents @agenteract/server @agenteract/pty --registry http://localhost:4873`);
+    // Add puppeteer as it's a peer dependency for web launching
+    await runCommand(`cd "${testConfigDir}" && npm install @agenteract/cli @agenteract/agents @agenteract/server @agenteract/pty puppeteer --registry http://localhost:4873`);
     success('CLI packages installed from Verdaccio');
 
     // 5. Create agenteract config pointing to the temp app
@@ -247,112 +246,41 @@ export default defineConfig({
     // Give servers time to start
     await sleep(5000);
 
-    // Check dev logs to see what port Vite is running on
+    // Wait for Vite dev server to be ready
+    info('Waiting for Vite dev server to start...');
+    await sleep(10000); // Give Vite time to compile and start
+
+    // Check dev logs to confirm server is running
     info('Checking Vite dev server logs...');
     try {
-      await runAgentCommand(`cwd:${testConfigDir}`, 'dev-logs', 'react-app', '--since', '50');
+      const devLogs = await runAgentCommand(`cwd:${testConfigDir}`, 'dev-logs', 'react-app', '--since', '50');
+      info('Vite dev logs:');
+      console.log(devLogs);
     } catch (err) {
       error(`Failed to get dev logs: ${err}`);
     }
 
-    // 6. Launch headless browser with Puppeteer
-    info('Launching headless browser...');
-    browser = await puppeteer.launch({
-      headless: true,
-      args: [
-        '--no-sandbox',
-        '--disable-setuid-sandbox',
-        '--disable-web-security', // Allow module loading in headless mode
-        '--disable-features=IsolateOrigins,site-per-process',
-      ],
-    });
-
-    const page = await browser.newPage();
+    success('Vite dev server started - YAML test will handle browser launch');
 
-    info('Opening http://localhost:5173 in headless browser...');
-    await page.goto('http://localhost:5173', {
-      waitUntil: 'networkidle0',
-      timeout: 60000,
-    });
-    success('Browser navigation complete');
+    // 9. Run YAML test
+    info('Running YAML test suite...');
+    const testFilePath = join(process.cwd(), 'tests', 'e2e', 'vite', 'test-app.yaml');
+    const testResult = await runAgentCommand(`cwd:${testConfigDir}`, 'test', testFilePath);
 
-    // Wait for React to actually render
-    info('Waiting for React app to render...');
-    try {
-      await page.waitForFunction(
-        () => {
-          const root = document.getElementById('root');
-          return root && root.children.length > 0;
-        },
-        { timeout: 30000 }
-      );
-      success('React app rendered');
-    } catch (err) {
-      error('React app did not render within 30 seconds');
-      throw new Error('React app failed to render');
-    }
+    // Parse JSON result
+    const result = JSON.parse(testResult);
 
-    let hierarchy: string | null = null;
-
-    await waitFor(
-      async () => {
-        try {
-          hierarchy = await runAgentCommand(`cwd:${testConfigDir}`, 'hierarchy', 'react-app');
-          info(`page content: ` + await page.content());
-          // print page console logs
-          info(`Hierarchy: ${hierarchy}`);
-
-          // Follow up with separate logs command to verify state (testing config waitLogTimeout: 0)
-          const appLogs = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'react-app', '--since', '10');
-          info('App logs:');
-          console.log(appLogs);
-
-          const devLogs = await runAgentCommand(`cwd:${testConfigDir}`, 'dev-logs', 'react-app', '--since', '50');
-          info('Vite dev logs:');
-          console.log(devLogs);
-
-          return hierarchy?.includes('Agenteract Web Demo');
-        } catch (err) {
-          error(`Error getting hierarchy: ${err}`);
-          return false;
-        }
-      },
-      'Vite dev server to start',
-      300000,
-      5000
-    );
+    // Log the full result for debugging
+    info('Test Result:');
+    console.log(JSON.stringify(result, null, 2));
 
-    if (!hierarchy) {
-      throw new Error('Unexpected error: hierarchy not found');
+    // Verify test passed
+    if (result.status !== 'passed') {
+      error(`Test failed at step ${result.failedAt}: ${result.error}`);
+      throw new Error(`YAML test failed: ${result.error}`);
     }
 
-    // 9. Get hierarchy and verify UI loaded
-    info('Fetching UI hierarchy...');
-
-    // Basic assertions - verify app loaded correctly
-    assertContains(hierarchy, 'Agenteract Web Demo', 'UI contains app title');
-    assertContains(hierarchy, 'test-button', 'UI contains test button');
-    assertContains(hierarchy, 'username-input', 'UI contains username input');
-    success('UI hierarchy fetched successfully');
-
-    // 10. Test tap interaction
-    info('Testing tap interaction on test-button...');
-    const tapResult = await runAgentCommand(`cwd:${testConfigDir}`, 'tap', 'react-app', 'test-button');
-    console.log(tapResult);
-    assertContains(tapResult, '"status":"ok"', 'Tap command executed successfully');
-    success('Button tap successful');
-
-    // 11. Verify tap was logged
-    await sleep(500); // Give app time to log the tap
-    const logsAfterTap = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'react-app', '--since', '5');
-    assertContains(logsAfterTap, 'Simulate button pressed', 'Button press was logged');
-    success('Button tap verified in logs');
-
-    // 12. Get all logs to verify app is running
-    info('Fetching app logs...');
-    const logs = await runAgentCommand(`cwd:${testConfigDir}`, 'logs', 'react-app', '--since', '15');
-    info('Recent logs:');
-    console.log(logs);
+    success(`✅ YAML test passed! (${result.steps.length} steps in ${result.duration}ms)`);
 
     success('✅ All tests passed!');
 
@@ -360,7 +288,7 @@ export default defineConfig({
     error(`Test failed: ${err}`);
     process.exit(1);
   } finally {
-    // await cleanup();
+    await cleanup();
     process.exit(0);
   }
 }
diff --git a/tests/e2e/vite/test-app.yaml b/tests/e2e/vite/test-app.yaml
new file mode 100644
index 0000000..40106d4
--- /dev/null
+++ b/tests/e2e/vite/test-app.yaml
@@ -0,0 +1,119 @@
+# Vite App E2E Test
+# Tests app lifecycle, UI hierarchy fetching, interactions, and agentLink functionality
+
+project: react-app
+timeout: 30000
+
+steps:
+  # 1. Launch browser
+  - phase: "Launch Browser"
+  - launch: app
+    waitForReady: true
+    timeout: 60000
+
+  # 2. Verify UI loaded correctly
+  - phase: "Verify Initial UI"
+  - assert:
+      exists: test-button
+
+  - assert:
+      exists: username-input
+
+  - assert:
+      exists: swipeable-card
+
+  - assert:
+      exists: horizontal-scroll
+
+  # 3. Test tap interaction
+  - phase: "Test Tap Interaction"
+  - tap: test-button
+    wait: 500
+
+  - assert:
+      logContains: "Simulate button pressed"
+
+  # 4. Test input interaction
+  - phase: "Test Input Interaction"
+  - input: username-input
+    value: "TestUser123"
+
+  - sleep: 300
+
+  # 5. Test AgentLink - Reset State (Example 1)
+  - phase: "AgentLink Test - Reset State"
+  
+  - agentLink: "agenteract://reset_state"
+    timeout: 3000
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 5000
+
+  # 6. Verify state was actually reset
+  - phase: "Verify State Reset"
+  - sleep: 500
+
+  # Input should be cleared after reset
+  # (We can verify by checking logs or re-interacting)
+
+  # 7. Test multiple interactions to set state again
+  - phase: "Set State Again"
+  - input: username-input
+    value: "AnotherUser"
+  
+  - tap: test-button
+
+  # 8. Test AgentLink - Navigate Action (Example 2)
+  - phase: "AgentLink Test - Navigate"
+  
+  - agentLink: "agenteract://navigate?screen=settings"
+    timeout: 3000
+
+  - waitFor: ""
+    logContains: "Navigate to screen: settings"
+    timeout: 5000
+
+  # 9. Test App Lifecycle - Stop and Restart
+  - phase: "Test App Lifecycle - Stop"
+  
+  - stop: app
+
+  - phase: "Test App Lifecycle - Relaunch"
+  
+  - launch: app
+    waitForReady: true
+    timeout: 60000
+
+  # 10. Wait for app to reach test screen
+  - phase: "Verify App Reached Test Screen"
+  
+  - waitFor: test-button
+    timeout: 10000
+
+  - assert:
+      exists: test-button
+
+  - assert:
+      exists: username-input
+
+  # 11. Test one more interaction after restart
+  - phase: "Test After Restart"
+  
+  - tap: test-button
+
+  - assert:
+      logContains: "Simulate button pressed"
+
+  # 12. Final AgentLink test to confirm it still works
+  - phase: "Final AgentLink Test"
+  
+  - agentLink: "agenteract://reset_state"
+
+  - waitFor: ""
+    logContains: "App state cleared"
+    timeout: 5000
+
+  # 13. Final cleanup
+  - phase: "Final Cleanup"
+  - stop: app
